<!--
==========
CHANGE LOG
==========
2023.3.21.0
-Add Certificate.Monitoring to switch statement in SCOM.AlertManagement.ps1.
-Add "CompanyName AD Management" support team.
-Add custom ADFS certificate alerts category.
2023.2.16.1
-Add $AlertName switch statement to SCOM.AlertManagement.ps1.
2023.2.15.0
-Add Commvault.Monitoring to switch statement in SCOM.AlertManagement.ps1.
2023.2.1.0
-Fix typo for get TLS and get services tasks.
2022.12.1.0
-Add VMware.WorkspaceOne.Monitoring to switch statement in SCOM.AlertManagement.ps1.
2022.11.17.0
-Remove 'Windows.TimeDrift' from switch statement in SCOM.AlertManagement.ps1
-Add ActiveDirectory.Monitoring to switch statement in SCOM.AlertManagement.ps1.
2022.10.12.0
-Add SCOM.Task.RunCommand.
2022.8.24.0
-Add 'Client' to 'Process alerts' section for desktop (Win 10) monitoring.
-Redo management group section.
2022.7.18.4
-Major rename of all elements.
2022.7.18.1
-Fixed bug SCOM.GetWindowsDiskInfo.ps1 doesn't work on 2008, gets a weird error. It was a bad where clause.
2022.7.18.0
-Add PowerShell version to header in SCOM.Task.RemoveMgmtGroup task.
2022.7.14.0
-Add SCOM.Task.RemoveMgmtGroup task.
2022.6.1.0
-Removed Information alerts from Summary table in SCOM.WAM.URDailyReport daily report. Should have been done in 2022.5.31.0.
2022.5.31.1
-Change target of SCOM.Monitor.WindowsInventoryScript from 'SystemCenter!Microsoft.SystemCenter.HealthService' to 'SCOM.Class.URWindowsComputer'.
Reasons for the change:
A) We want to see health state in the 'Windows Agents' view.
B) If there happens to be a problem while the discovery script executes it will be picked up by another alert anyway.
2022.5.31.0
-Removed Information alerts from Active Alerts table in SCOM.WAM.URDailyReport daily report.
2022.5.30.0
-Add owner and category for alert  Microsoft.Unix.LogFileModuleErrors.Alert to SCOM.WAM.URAlertManagement.
2022.5.19.4
-Change discovery target for SCOM.Discovery.WindowsComputer to Microsoft.SystemCenter.HealthService.
2022.5.18.0
-Change alert priority to Medium for SCOM.Monitor.AlertManagementMissedEvent.
2022.5.9.1
-Change 'tb1.InMaintenanceMode=0' to 'is null' in SCOM.DailyReport.ps1.
2022.4.20.1
-Add McAfee to switch statement in SCOM.AlertManagement.ps1.
2022.3.29.0
-Add Cmdb to switch statement in SCOM.AlertManagement.ps1.
2022.2.25.0
-Add ADFS to switch statement in SCOM.AlertManagement.ps1.
-Add Commvault & IntelliSnap to switch statement in SCOM.AlertManagement.ps1.
-Add Windows TimeDrift to switch statement in SCOM.AlertManagement.ps1.
-Add support teams for Citrix, SharePoint and SCCM to SCOM.AlertManagement.ps1.
2022.1.19.0
-Change alerts from "Microsoft.SystemCenter.*" mp to go go Monitoring team.
2022.1.17.1
-Change "$owner=$unknown_team" to "$owner=$Unknown" in SCOM.AlertManagement.ps1
2022.1.17.0
-Add SCCM to switch statement in SCOM.AlertManagement.ps1.
2022.1.13.0
-Changed this line because the query was broken:
From: INNER JOIN ManagedTypeView as tb2
To: INNER JOIN [$Script:OpsDbName].[dbo].[ManagedTypeView] as tb2
2021.12.22.0
-Add description to SCOM.Rule.AlertManagementScript.
-Add DNS and DHCP to switch statement in SCOM.AlertManagement.ps1.
-Remove "Update required - " in discovery script.
-Add line "$ActiveAlerts=$ActiveAlerts -replace '<td>Unknown','<td class="Warning">Unknown'".
2021.12.17.1
-Add workflow: SCOM.Rule.DailyReport.
-Rename "Alert Management Script Error" to "Alert Management Script" and related areas.
2021.12.15.1
-Change "Microsoft.Exchange.15" to "*Exchange.*" in SCOM.WAM.URAlertManagement write action module.
2021.12.15.0
-Fix mp version in scripts.
-Add description to SCOM.Rule.AlertManagement rule.
-Change interval to 10 for SCOM.Monitor.AlertManagementMissedEvent monitor.
13.12.2021
-Add workflow: SCOM.Rule.AlertManagement, SCOM.Rule.AlertManagementScript, SCOM.Monitor.AlertManagementMissedEvent
16.11.2021
-Remove "-Directory" from this line because it doesn't work on 2008.
$AgentMGFolders=Get-ChildItem -Directory -Path "$AgentInstallDirectory\Health Service State\Connector Configuration Cache"
-Changed all instances of "Get-CimInstance -ClassName" to "Get-WmiObject" because 2008 doesn't support Get-CimInstance (or pshell version)
====
BUGS
====
3.3.2022
-ACS Collectors state view is wrong. It's showing '%\% console install directory'.
============
ENHANCEMENTS
============
-Change 'Agent MG Failovers' to just show mgmt group names. Currently, if there's too many it gets cut off. We can use other scripts to show agent failover.
-Add to daily report a table showing top 10 list of servers with low disk space.
-Add event monitor for SCOM.Rule.DailyReport.
-Add agent load balance script (code in TFS) as task? 
-Add the word Rule/Monitor to custom field so Operators know what type of alert it is?
-->
<ManagementPack ContentReadable="true" SchemaVersion="2.0" OriginalSchemaVersion="1.1" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<Manifest>
<Identity>
<ID>SCOM.UpdateRollup</ID>
<Version>2023.3.21.0</Version>
</Identity>
<Name>SCOM.UpdateRollup</Name>
<References>
<Reference Alias="Windows">
<ID>Microsoft.Windows.Library</ID>
<Version>7.5.8501.0</Version>
<PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
</Reference>
<Reference Alias="System">
<ID>System.Library</ID>
<Version>7.5.8501.0</Version>
<PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
</Reference>
<Reference Alias="SystemCenter">
<ID>Microsoft.SystemCenter.Library</ID>
<Version>7.0.8433.0</Version>
<PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
</Reference>
<Reference Alias="Health">
<ID>System.Health.Library</ID>
<Version>7.0.8433.0</Version>
<PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
</Reference>
</References>
</Manifest>
<TypeDefinitions>
<EntityTypes>
<ClassTypes>
<!--**************************************** WINDOWS PROPERTIES ****************************************-->
<!--
<ClassType ID="SCOM.Class.URWindowsComputer" Accessibility="Public" Abstract="false" Base="Windows!Microsoft.Windows.ApplicationComponent" Hosted="true" Singleton="false" Extension="false">
-->
<ClassType ID="SCOM.Class.URWindowsComputer" Accessibility="Public" Abstract="false" Base="Windows!Microsoft.Windows.LocalApplication" Hosted="true" Singleton="false" Extension="false"><Property ID="OperatingSystem" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="Product" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="AgentInstallDirectory" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="AgentLastUpdate" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="AgentVersion" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<!--
<Property ID="AgentMGCount" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="AgentMGFailovers" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
-->
<Property ID="MGCount" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="MGNames" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="HealthServiceAccount" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="HealthServiceStartMode" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="CertificateExpiry" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ADIntegration" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="APMInstalled" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="APMServiceAccount" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="APMServiceStartMode" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ACSForwarderServiceAccount" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ACSForwarderServiceStartMode" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="TLS12" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="LAWorkspaceCount" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="LAWorkspaces" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="LAProxyUrl" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="LAProxyUsername" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ComputerType" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="MgmtServerInstallDirectory" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="MgmtServerLastUpdate" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="MgmtServerVersion" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ConfigServiceAccount" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ConfigServiceStartMode" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="DataAccessServiceAccount" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="DataAccessServiceStartMode" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="OpsDbName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="OpsDbServer" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="DWDbName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="DwDbServer" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ACSCollector" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ACSCollectorServiceAccount" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ACSCollectorServiceStartMode" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ACSCollectorLastUpdate" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ACSCollectorVersion" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="RMS" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="GatewayServerInstallDirectory" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="GatewayServerLastUpdate" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="GatewayServerVersion" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<!--
<Property ID="GatewayMGCount" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="GatewayMGFailovers" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
-->
<Property ID="WebConsoleInstallDirectory" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="WebConsoleLastUpdate" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="WebConsoleVersion" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="AuthenticationMode" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="DefaultServer" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="WebConsoleUrl" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ApmAdvisorUrl" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ApmDiagnosticsUrl" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ReportServerInstallDirectory" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ReportServerLastUpdate" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ReportServerVersion" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ReportServerDwDbServer" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ReportServerDWDBName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ReportServerUrl" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="SRSInstance" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ReportServerServiceAccount" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ReportServerServiceStartMode" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ConsoleVersion" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ConsoleInstallDirectory" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
<Property ID="ConsoleLastUpdate" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
</ClassType>
</ClassTypes>
<!--<RelationshipTypes>
<RelationshipType ID="SCOM.Relationship.WindowsComputerHostsSCOMClassWindowsComputer" Accessibility="Public" Abstract="false" Base="System!System.Hosting">
<Source ID="Source" Type="Windows!Microsoft.Windows.Computer" />
<Target ID="Target" Type="SCOM.Class.URWindowsComputer" />
</RelationshipType>
</RelationshipTypes>
-->
</EntityTypes>
<ModuleTypes>
<!--**************************************** WINDOWS DISCOVERY DATA SOURCE MODULE ****************************************-->
<DataSourceModuleType ID="SCOM.DSM.URWindowsComputer" Accessibility="Internal" Batching="false">
<Configuration>
<xsd:element name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
</Configuration>
<OverrideableParameters>
<OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
<OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
<OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
</OverrideableParameters>
<ModuleImplementation Isolation="Any">
<Composite>
<MemberModules>
<DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedPowerShell.DiscoveryProvider">
<IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
<SyncTime>$Config/SyncTime$</SyncTime>
<ScriptName>SCOM.WindowsInventory.ps1</ScriptName>
<ScriptBody><![CDATA[
# Start Windows discovery
Param ($SourceId,$ManagedEntityId,$ComputerName) # Need this line to pass params in properly.
<#**************************************** FUNCTION: LogAndQuit ****************************************#>
Function LogAndQuit {
If ($Script:CountError -gt 0) {
$EventId=17611
$EventLevel=2
}
Else {
$Script:CountError=0 # If no errors set this value so it appears in the event.
$EventId=17610
$EventLevel=0
}
# Use MOMScriptAPI.LogScriptEvent method to log events because Write-EventLog doesn't work on new OSs.
$ObjMomApi.LogScriptEvent("SCOM.WindowsInventory.ps1", $EventId, $EventLevel, "Windows inventory discovery script executed.`nWorkflow Name: SCOM.Discovery.WindowsComputer`nManagement Pack: SCOM.UpdateRollup (2023.3.21.0)`nPowerShell Version: $PSVersion`nIssues Detected: $Script:CountError`n$Script:Message") # $Error dumps errors into the event.
}
<#**************************************** FUNCTION: CheckNull ****************************************#>
Function CheckNull ($PassedInParam) {
If ([string]::IsNullOrEmpty($PassedInParam)) {
$Script:IsItNull=$True # Update this so we can make decisions.
If ($ValueToCheck -eq "LAProxyUrl") { # This If statement allows us to do custom things when an empty value is not considered an error.
$Script:LAProxyUrl="n/a"
}
ElseIf ($ValueToCheck -eq "LAProxyUsername") {
$Script:LAProxyUsername="n/a"
}
Else {
$Script:CountError+=1
$Script:Message+="[CODE_SECTION_$CodeSection] $ValueToCheck is empty. Error output: ($Error).`n"
}
}
Else {
$Script:IsItNull=$False # Update this so we can make decisions.
}
}
<#**************************************** FUNCTION: TerminatingError ****************************************#>
Function TerminatingError
{
$script:CountError+=1
$script:Message+="[CODE_SECTION_$CodeSection] A terminating error occurred. Error output: (" + $_.Exception.Message + ").`n"
LogAndQuit
}
<#**************************************** FUNCTION: GetServiceInfo ****************************************#>
Function GetServiceInfo ($PassedInParam) {
$Script:ServiceAccount=$null; $Script:ServiceStartMode=$null # Reset these.
$Script:ServiceAccount=(Get-ItemProperty $PassedInParam).ObjectName
$ValueToCheck="ServiceAccount"; CheckNull $ServiceAccount # Expect value.
$Script:ServiceStartMode=(Get-ItemProperty $PassedInParam).Start
$ValueToCheck="ServiceStartMode"; CheckNull $Script:ServiceStartMode # Expect value.
If ($Script:IsItNull -ne $True) { # 
Switch ($Script:ServiceStartMode) {
"2" {$Script:ServiceStartMode="Automatic"; BREAK}
"3" {$Script:ServiceStartMode="Manual"; BREAK}
"4" {$Script:ServiceStartMode="Disabled"; BREAK}
}
}
}
<#**************************************** FUNCTION: CheckFile ****************************************#>
<#
If you add "NoAlert" as second parameter it won't generate alert.
#>
Function CheckFile ($Script:PassedInParam, $Script:PassedInParam2) {
If(Test-Path $script:PassedInParam) {
$Script:FileExists=$True # Update this so we can make decisions.
$script:GetFile=Get-Item $script:PassedInParam
$script:FileLastAccessTimeRaw=$script:GetFile.LastAccessTime
$script:FileLastAccessTime=$script:GetFile.LastAccessTime.ToString("yyyy/MM/dd HH:mm:ss")
$script:FileVersion=$script:GetFile.VersionInfo.FileVersion
}
Else {
$Script:FileExists=$False # Update this so we can make decisions.
If (-Not($Script:PassedInParam2 -eq "NoAlert")) {
$Script:CountError+=1
$Script:Message+="[CODE_SECTION_$CodeSection] File not found: $PassedInParam.`n"
}}}
<#**************************************** FUNCTION: GetWindowsInventory ****************************************#>
Function GetWindowsInventory {
$ErrorActionPreference="Continue"
Try {
<# FOR TESTING
$SourceId='{00000000-0000-0000-0000-000000000000}'
$ManagedEntityId='{00000000-0000-0000-0000-000000000000}'
$ComputerName='agent.scomtest.local'
#>
<# CODE_SECTION_1
Load required objects.
#>
$CodeSection="1"
$ObjMomApi=New-Object -comObject 'MOM.ScriptAPI' # MOMScriptAPI object.
$DiscoveryData=$ObjMomApi.CreateDiscoveryData(0, $SourceId, $ManagedEntityId) # Create MOMDiscoveryData object to store discovery data.
$ObjAgentConfig=New-Object -ComObject "AgentConfigManager.MgmtSvcCfg" # Agent config API object.
<# CODE_SECTION_2.
Get powershell version.
This is shown in events to assist troubleshooting if powershell doesn't play nice.
#>
$CodeSection="2"
$PSVersion=$PSVersionTable.PSVersion
[string]$PSMajor=$PSVersion.Major
[string]$PSMinor=$PSVersion.Minor
$PSVersion=$PSMajor + "." + $PSMinor
<# CODE_SECTION_3
Set common variables.
#>
$CodeSection="3"
$ComputerFqdn=([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname
$ValueToCheck="ComputerFqdn"; CheckNull $ComputerFqdn # Expect value.
$WinDir=(Get-ChildItem Env:windir).Value
$ValueToCheck="WinDir"; CheckNull $WinDir # Expect value.
<# CODE_SECTION_4
Get operating system.
#>
$CodeSection="4"
$OperatingSystem=(Get-WmiObject Win32_OperatingSystem).Caption
$ValueToCheck="OperatingSystem"; CheckNull $OperatingSystem # Expect value.
<# CODE_SECTION_5
Determine SCOM role of the computer.
#>
$CodeSection="5"
$SetupRegKey="HKLM:\SOFTWARE\Microsoft\Microsoft Operations Manager\3.0\Setup"
$Product=(Get-ItemProperty $SetupRegKey).Product # No null check. Script execution means it's present.
<#**************************************** AGENT SECTION ****************************************#>
<# CODE_SECTION_6
Get agent install directory.
#>
$CodeSection="6"
If((Get-ItemProperty $SetupRegKey).AgentVersion) { # No null check. Script execution means it's present.
$AgentInstallDirectory=(Get-ItemProperty $SetupRegKey).InstallDirectory.TrimEnd("\") # No null check. Script execution means it's present.
<# CODE_SECTION_7
Get agent UR info.
#>
$CodeSection="7"
$AgentURFile="$AgentInstallDirectory\Tools\TMF\OMAgentTraceTMFVer.Dll" # Best file for UR info.
CheckFile $AgentURFile # Alert if file doesn't exist.
If ($Script:FileExists -eq $True) {
$AgentLastUpdate=$Script:FileLastAccessTime # Determines when UR was installed.
$ValueToCheck="AgentLastUpdate"; CheckNull $AgentLastUpdate # Expect value.
$AgentVersion=$Script:FileVersion
$ValueToCheck="AgentVersion"; CheckNull $AgentVersion # Expect value.
If ($Script:IsItNull -ne $True) {
Switch($AgentVersion) {
# SCOM 2012 R2
"7.1.10184.0" {$AgentVersion="2012 R2 RTM"; BREAK}
"7.1.10195.0" {$AgentVersion="2012 R2 UR2"; BREAK}
"7.1.10204.0" {$AgentVersion="2012 R2 UR3"; BREAK}
"7.1.10211.0" {$AgentVersion="2012 R2 UR4"; BREAK}
"7.1.10213.0" {$AgentVersion="2012 R2 UR5"; BREAK}
"7.1.10218.0" {$AgentVersion="2012 R2 UR6"; BREAK}
"7.1.10229.0" {$AgentVersion="2012 R2 UR7"; BREAK}
"7.1.10241.0" {$AgentVersion="2012 R2 UR8"; BREAK}
"7.1.10268.0" {$AgentVersion="2012 R2 UR9"; BREAK}
"7.1.10285.0" {$AgentVersion="2012 R2 UR11"; BREAK}
"7.1.10292.0" {$AgentVersion="2012 R2 UR12"; BREAK}
"7.1.10302.0" {$AgentVersion="2012 R2 UR13"; BREAK}
"7.1.10305.0" {$AgentVersion="2012 R2 UR14"; BREAK}
# SCOM 2016
"8.0.10918.0" {$AgentVersion="2016 RTM"; BREAK}
"8.0.10931.0" {$AgentVersion="2016 UR1"; BREAK}
"8.0.10949.0" {$AgentVersion="2016 UR2"; BREAK}
"8.0.10970.0" {$AgentVersion="2016 UR3"; BREAK}
"8.0.10977.0" {$AgentVersion="2016 UR4"; BREAK}
"8.0.10990.0" {$AgentVersion="2016 UR5"; BREAK}
"8.0.11004.0" {$AgentVersion="2016 UR6"; BREAK}
"8.0.11025.0" {$AgentVersion="2016 UR7"; BREAK}
"8.0.11037.0" {$AgentVersion="2016 UR8"; BREAK}
"8.0.11049.0" {$AgentVersion="2016 UR9"; BREAK}
"8.0.11057.0" {$AgentVersion="2016 UR10"; BREAK}
# SCOM 1801
"8.0.13053.0" {$AgentVersion="1801"; BREAK}
"8.0.13067.0" {$AgentVersion="1807"; BREAK}
# SCOM 2019
"10.19.10014.0" {$AgentVersion="2019 RTM"; BREAK}
"10.19.10140.0" {$AgentVersion="2019 UR1"; BREAK}
"10.19.10153.0" {$AgentVersion="2019 UR2"; BREAK}
Default {
$Script:Message+="[CODE_SECTION_$CodeSection] Unknown agent version: $AgentVersion.`n"; # Catch unknown versions.
$AgentVersion="Unknown version - $AgentVersion"
}}}}
} # end big "if agent" section
Else
{
$AgentInstallDirectory="n/a"
$AgentLastUpdate="n/a"
$AgentVersion="n/a"
#$AgentMGFailovers="n/a"
#$AgentMGCount="n/a"
}
<#**************************************** COMMON SECTION ****************************************#>
<# CODE_SECTION_9
Get management groups on agents, mgmt/gateway servers.
The folder is the best way to check for invalid mgmt groups that didn't clean up properly after removal.
#>
$InstallDirectory=(Get-ItemProperty $SetupRegKey).InstallDirectory.TrimEnd("\")
$MGFolders=Get-ChildItem -Path "$InstallDirectory\Health Service State\Connector Configuration Cache"
$MGCount=($MGFolders | Measure-Object).Count
$MGFolders | ForEach-Object {
$MGName=$_.Name
write-host -foregroundcolor red "$MGName"
$MGNames+="$MGName,"
$ConfigFile="$InstallDirectory\Health Service State\Connector Configuration Cache\$MGName\OpsMgrConnector.Config.xml" # Script is running so don't check for existence.
If (-not(Test-Path -Path $ConfigFile)) {
$Script:Message+="[CODE_SECTION_$CodeSection] Management group '$MGName' is missing OpsMgrConnector.Config.xml file.`n"
$Script:CountError+=1
}
} # end for
$MGNames=$MGNames.TrimEnd(",")


<# CODE_SECTION_9
Get HealthService account and start mode.
#>
$CodeSection="9"
$HealthServiceRegKey="HKLM:\SYSTEM\CurrentControlSet\Services\HealthService"
GetServiceInfo $HealthServiceRegKey
$Script:HealthServiceAccount=$Script:ServiceAccount
$Script:HealthServiceStartMode=$Script:ServiceStartMode
<# CODE_SECTION_10
Get certificate.
#>
$CodeSection="10"
$CertRegKey="HKLM:\SOFTWARE\Microsoft\Microsoft Operations Manager\3.0\Machine Settings"
If ((Get-ItemProperty $CertRegKey).ChannelCertificateHash) {
$Hash=(Get-ItemProperty $CertRegKey).ChannelCertificateHash
$Thumbprint=Get-ChildItem -Path cert:\LocalMachine\My | Where-Object {$_.Thumbprint -eq $Hash}
$CertificateExpiry=$Thumbprint.NotAfter.ToString("yyyy/MM/dd HH:mm:ss")
$ValueToCheck="CertificateExpiry"; CheckNull $CertificateExpiry # Expect value.
}
Else {
$CertificateExpiry="n/a"
}
<# CODE_SECTION_11
Get AD Integration setting.
#>
$CodeSection="11"
$ADIntegRegKey="HKLM:\SYSTEM\CurrentControlSet\Services\HealthService\Parameters\ConnectorManager"
$ADIntegration=(Get-ItemProperty $ADIntegRegKey).EnableADIntegration
$ValueToCheck="ADIntegration"; CheckNull $ADIntegration # Expect value.
If ($Script:IsItNull -ne $True) {
Switch ($ADIntegration) {
"0" {$ADIntegration="Disabled"; BREAK}
"1" {$ADIntegration="Enabled"; BREAK}
Default {
$Script:Message+="[CODE_SECTION_$CodeSection] Unknown AD Integration value: $ADIntegration`n";
$Script:CountError+=1
}
}}
<# CODE_SECTION_12
Get APM service StartMode type.
This may not be installed so don't alert if not found.
#>
$CodeSection="12"
$APMServiceRegKey="HKLM:\SYSTEM\CurrentControlSet\Services\System Center Management APM"
If (Test-Path $APMServiceRegKey) {
$APMInstalled="Yes"
GetServiceInfo $APMServiceRegKey
$Script:APMServiceAccount=$Script:ServiceAccount
$Script:APMServiceStartMode=$Script:ServiceStartMode
}
Else {
$APMInstalled="No"
$APMServiceAccount="n/a"
$APMServiceStartMode="n/a"
}
<# CODE_SECTION_13
Get ACS forwarder.
This should be installed on all ms, gw, agent. Alert if not found.
#>
$CodeSection="13"
$ACSForwarderServiceRegKey="HKLM:SYSTEM\CurrentControlSet\Services\AdtAgent"
GetServiceInfo $ACSForwarderServiceRegKey
$Script:ACSForwarderServiceAccount=$Script:ServiceAccount
$Script:ACSForwarderServiceStartMode=$Script:ServiceStartMode
<# CODE_SECTION_14
Get TLS1.2 registry settings.
This checks if the server has been explicitly configured to communicate with only TLS1.2 (i.e. all other protocols disabled).
#>
$CodeSection="14"
$Count=0
$ArrayTLS12NETEnabled="HKLM:\SOFTWARE\Microsoft\.NETFramework\v4.0.30319","HKLM:\SOFTWARE\WOW6432Node\Microsoft\.NETFramework\v4.0.30319"
$ArrayTLS12NETEnabled | ForEach-Object {
If (Test-Path -Path $_) {
$TLS12NETEnabled=(Get-ItemProperty $_).SchUseStrongCrypto
If ($TLS12NETEnabled -eq 1) {
$Count+=1
}
}
}
$TLS12OSRegKey="HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.2"
$ArrayTLS12OS="Client","Server"
$ArrayTLS12OS | ForEach-Object {
If (Test-Path -Path "$TLS12OSRegKey\$_") {
$TLS12OSEnabled=(Get-ItemProperty "$TLS12OSRegKey\$_").Enabled
$TLS12OSDisabledByDefault=(Get-ItemProperty "$TLS12OSRegKey\$_").DisabledByDefault
If ($TLS12OSEnabled -eq 1 -and $TLS12OSDisabledByDefault -eq 0) {
$Count+=1
}
}
}
If ($Count -eq 0) {
$TLS12="NoConfig"
}
ElseIf ($Count -eq 4) {
$TLS12="CorrectConfig"
}
Else {
$TLS12="IncompleteConfig"
}
<# CODE_SECTION_15
Get Log Analytics workspaces.
Using the AgentConfigManager.MgmtSvcCfg object isn't reliable for collecting LA workspace info so we use the registry instead.
#>
$CodeSection="15"
$LAWorkspaceRegKey="HKLM:\SYSTEM\CurrentControlSet\Services\HealthService\Parameters\Service Connector Services"
If (Test-Path $LAWorkspaceRegKey) {
$BindLAWorkspaceRegKey=Get-Item $LAWorkspaceRegKey # Bind to the reg key so we can get properties.
$LAWorkspaceCount=($BindLAWorkspaceRegKey).SubKeyCount # This is the $LAWorkspaceCount property.
If ($LAWorkspaceCount -gt 0) { # If 0 workspaces set $LAWorkspaces to "None" otherwise do below...
$ArrayLAWorkspaces=$BindLAWorkspaceRegKey.GetSubKeyNames() # Get each subkey and create an array in case there's more than 1.
$ArrayLAWorkspaces | ForEach-Object { # Cycle through each item in the array.
$LAWorkspaceId=$_.Substring(16) # Remove "Log Analytics - " from the key name so we just have the workspace id.
$LAWorkspaceType=(Get-ItemProperty -Path $LAWorkspaceRegKey\$_)."Azure Cloud Type"
$ValueToCheck="LAWorkspaceType"; CheckNull $LAWorkspaceType
If ($Script:IsItNull -ne $True) { # 
Switch ($LAWorkspaceType) {
"0" {$LAWorkspaceType="Azure Commercial"; BREAK}
"1" {$LAWorkspaceType="Azure US Government"; BREAK}
"2" {$LAWorkspaceType="Azure China"; BREAK}
"3" {$LAWorkspaceType="Azure US Nat"; BREAK}
"4" {$LAWorkspaceType="Azure US Sec"; BREAK}
Default {
$Script:Message+="[CODE_SECTION_$CodeSection] Unknown log analytics workspace type: $LAWorkspaceType`n";
$Script:CountError+=1
}
}
}
$LAWorkspaces+="Type=$LAWorkspaceType,WorkSpaceId=$LAWorkspaceId;"
}
$LAWorkspaces=$LAWorkspaces.TrimEnd(";")
}
Else {
$LAWorkspaceCount="0"
$LAWorkspaces="n/a"
}
}
Else {
$LAWorkspaceCount="0"
$LAWorkspaces="n/a"
}
<# CODE_SECTION_16
Get Log Analytics proxy server used to connect to Log Analytics.
If this is empty it's not an error but we need to add custom discovery data so need a null check. There is a reference in the CheckNull function for this. It's not pretty but it let's us reuse code.
#>
$CodeSection="16"
$Script:LAProxyUrl=$ObjAgentConfig.proxyUrl
$ValueToCheck="LAProxyUrl"; CheckNull $Script:LAProxyUrl # Add custom discovery data
<# CODE_SECTION_17
Get Log Analytics account used to authenticate to the proxy server.
If this is empty it's not an error but we need to add custom discovery data so need a null check. There is a reference in the CheckNull function for this. It's not pretty but it let's us reuse code.
#>
$CodeSection="17"
$Script:LAProxyUsername=$ObjAgentConfig.proxyUsername
$ValueToCheck="LAProxyUsername"; CheckNull $Script:LAProxyUsername # Expect value.
<# CODE_SECTION_18
Get computer type.
#>
$CodeSection="18"
$ComputerType=(Get-WmiObject Win32_ComputerSystem).Model
$ValueToCheck="ComputerType"; CheckNull $ComputerType # Expect value.

<#**************************************** MGMT SERVER SECTION ****************************************#>
If((Get-ItemProperty $SetupRegKey).ServerVersion) { # start mgmt server section.
<# CODE_SECTION_19
Get mgmt server install directory.
#>
$CodeSection="19"
$MgmtServerInstallDirectory=(Get-ItemProperty $SetupRegKey).InstallDirectory.TrimEnd("\")
$ValueToCheck="MgmtServerInstallDirectory"; CheckNull $MgmtServerInstallDirectory # Expect value.
<# CODE_SECTION_20
Get management server UR info.
#>
$CodeSection="20"
$MgmtServerURFile="$MgmtServerInstallDirectory\Tools\TMF\OMTraceTMFVer.Dll" # Best file for UR info.
CheckFile $MgmtServerURFile # Alert if file doesn't exist.
If ($Script:FileExists -eq $True) {
$MgmtServerLastUpdate=$Script:FileLastAccessTime # Determines when UR was installed.
$ValueToCheck="MgmtServerLastUpdate"; CheckNull $MgmtServerLastUpdate # Expect value.
$MgmtServerVersion=$Script:FileVersion
$ValueToCheck="MgmtServerVersion"; CheckNull $MgmtServerVersion # Expect value.
If ($Script:IsItNull -ne $True) { # 
Switch($MgmtServerVersion) {
# SCOM 2012 R2
"7.1.10226.0" {$MgmtServerVersion="2012 R2 RTM"; BREAK}
"7.1.10226.1009" {$MgmtServerVersion="2012 R2 UR1"; BREAK}
"7.1.10226.1015" {$MgmtServerVersion="2012 R2 UR2"; BREAK}
"7.1.10226.1037" {$MgmtServerVersion="2012 R2 UR3"; BREAK}
"7.1.10226.1046" {$MgmtServerVersion="2012 R2 UR4"; BREAK}
"7.1.10226.1052" {$MgmtServerVersion="2012 R2 UR5"; BREAK}
"7.1.10226.1064" {$MgmtServerVersion="2012 R2 UR6"; BREAK}
"7.1.10226.1090" {$MgmtServerVersion="2012 R2 UR7"; BREAK}
"7.1.10226.1118" {$MgmtServerVersion="2012 R2 UR8"; BREAK}
"7.1.10226.1177" {$MgmtServerVersion="2012 R2 UR9"; BREAK}
"7.1.10226.1239" {$MgmtServerVersion="2012 R2 UR11"; BREAK}
"7.1.10226.1304" {$MgmtServerVersion="2012 R2 UR12"; BREAK}
"7.1.10226.1360" {$MgmtServerVersion="2012 R2 UR13"; BREAK}
"7.1.10226.1387" {$MgmtServerVersion="2012 R2 UR14"; BREAK}
# SCOM 2016
"7.2.11719.0" {$MgmtServerVersion="2016 RTM"; BREAK}
"7.2.11759.0" {$MgmtServerVersion="2016 UR1"; BREAK}
"7.2.11822.0" {$MgmtServerVersion="2016 UR2"; BREAK}
"7.2.11878.0" {$MgmtServerVersion="2016 UR3"; BREAK}
"7.2.11938.0" {$MgmtServerVersion="2016 UR4"; BREAK}
"7.2.12016.0" {$MgmtServerVersion="2016 UR5"; BREAK}
"7.2.12066.0" {$MgmtServerVersion="2016 UR6"; BREAK}
"7.2.12150.0" {$MgmtServerVersion="2016 UR7"; BREAK}
"7.2.12213.0" {$MgmtServerVersion="2016 UR8"; BREAK}
"7.2.12265.0" {$MgmtServerVersion="2016 UR9"; BREAK}
"7.2.12324.0" {$MgmtServerVersion="2016 UR10"; BREAK}
# SCOM 1801
"7.3.13142.0" {$MgmtServerVersion="1801"; BREAK}
"7.3.13261.0" {$MgmtServerVersion="1807"; BREAK}
# SCOM 2019
"10.19.10050.0" {$MgmtServerVersion="2019 RTM"; BREAK}
"10.19.10311.0" {$MgmtServerVersion="2019 UR1"; BREAK}
"10.19.10349.0" {$MgmtServerVersion="2019 UR1 Hotfix"; BREAK}
"10.19.10407.0" {$MgmtServerVersion="2019 UR2"; BREAK}
Default {
$Script:Message+="[CODE_SECTION_$CodeSection] Unknown management server version: $MgmtServerVersion.`n"; # Catch unknown versions.
$MgmtServerVersion="Unknown version - $MgmtServerVersion"
}}}}
<# CODE_SECTION_21
Get CSHostService account and start mode.
#>
$CodeSection="21"
$ConfigServiceRegKey="HKLM:\SYSTEM\CurrentControlSet\Services\cshost"
GetServiceInfo $ConfigServiceRegKey
$Script:ConfigServiceAccount=$Script:ServiceAccount
$Script:ConfigServiceStartMode=$Script:ServiceStartMode
<# CODE_SECTION_22
Get OMSDKService account and start mode.
#>
$CodeSection="22"
$DataAccessServiceRegKey="HKLM:\SYSTEM\CurrentControlSet\Services\OMSDK"
GetServiceInfo $DataAccessServiceRegKey
$Script:DataAccessServiceAccount=$Script:ServiceAccount
$Script:DataAccessServiceStartMode=$Script:ServiceStartMode
<# CODE_SECTION_23
Get ops db name.
#>
$CodeSection="23"
$OpsDbName=(Get-ItemProperty $SetupRegKey).DatabaseName
$ValueToCheck="OpsDbName"; CheckNull $OpsDbName # Expect value.
<# CODE_SECTION_24
Get ops db server name.
#>
$CodeSection="24"
$OpsDbServer=(Get-ItemProperty $SetupRegKey).DatabaseServerName
$ValueToCheck="OpsDbServer"; CheckNull $OpsDbServer # Expect value.
<# CODE_SECTION_25
Get data warehouse db name.
#>
$CodeSection="25"
$DWDbName=(Get-ItemProperty $SetupRegKey).DataWarehouseDBName
$ValueToCheck="DWDbName"; CheckNull $DWDbName # Expect value.
<# CODE_SECTION_26
Get data warehouse db server name.
#>
$CodeSection="26"
$DwDbServer=(Get-ItemProperty $SetupRegKey).DataWarehouseDBServerName
$ValueToCheck="DwDbServer"; CheckNull $DwDbServer # Expect value.
<# CODE_SECTION_27
# Get service info.
#>
$CodeSection="27"
$ACSCollectorServiceRegKey="HKLM:SYSTEM\CurrentControlSet\Services\AdtServer" # If this key exists it's an ACS collector.
If (Test-Path $ACSCollectorServiceRegKey) {
$ACSCollector="Yes"
GetServiceInfo $ACSCollectorServiceRegKey
$Script:ACSCollectorServiceAccount=$Script:ServiceAccount
$Script:ACSCollectorServiceStartMode=$Script:ServiceStartMode
<# CODE_SECTION_28
Get ACS collector UR info.
#>
$CodeSection="28"
$ACSCollectorURFile="$WinDir\System32\Security\AdtServer\OmacAdmn.dll" # Best file for UR info.
CheckFile $ACSCollectorURFile # Alert if file doesn't exist.
If ($Script:FileExists -eq $True) {
$ACSCollectorLastUpdate=$Script:FileLastAccessTime # Determines when UR was installed.
$ValueToCheck="ACSCollectorLastUpdate"; CheckNull $ACSCollectorLastUpdate # Expect value.
$ACSCollectorVersion=$Script:FileVersion
$ValueToCheck="ACSCollectorVersion"; CheckNull $ACSCollectorVersion # Expect value.
If ($Script:IsItNull -ne $True) { # 
Switch($ACSCollectorVersion) {
# SCOM 2012 R2
"7.1.10226.0" {$ACSCollectorVersion="2012 R2 RTM"; BREAK}
"7.1.10226.1239" {$ACSCollectorVersion="2012 R2 UR11"; BREAK}
"7.1.10226.1304" {$ACSCollectorVersion="2012 R2 UR12"; BREAK}
"7.1.10226.1360" {$ACSCollectorVersion="2012 R2 UR13"; BREAK}
"7.1.10226.1387" {$ACSCollectorVersion="2012 R2 UR14"; BREAK}
# SCOM 2016
"7.2.11719.0" {$ACSCollectorVersion="2016 RTM"; BREAK}		
"7.2.11938.0" {$ACSCollectorVersion="2016 UR4"; BREAK}		
"7.2.12016.0" {$ACSCollectorVersion="2016 UR5"; BREAK}
"7.2.12066.0" {$ACSCollectorVersion="2016 UR6"; BREAK}
"7.2.12150.0" {$ACSCollectorVersion="2016 UR7"; BREAK}
"7.2.12213.0" {$ACSCollectorVersion="2016 UR8"; BREAK}		
"7.2.12265.0" {$ACSCollectorVersion="2016 UR9"; BREAK}		
"7.2.12324.0" {$ACSCollectorVersion="2016 UR10"; BREAK}
# SCOM 1801
"7.3.13142.0" {$ACSCollectorVersion="1801"; BREAK}		
"7.3.13261.0" {$ACSCollectorVersion="1807"; BREAK}	
# SCOM 2019
"10.19.10050.0" {$ACSCollectorVersion="2019 RTM"; BREAK}
"10.19.10140.0" {$ACSCollectorVersion="2019 UR1"; BREAK}
Default {
$Script:Message+="[CODE_SECTION_$CodeSection] Unknown ACS collector version: $ACSCollectorVersion.`n"; # Catch unknown versions.
$ACSCollectorVersion="Unknown version - $ACSCollectorVersion"
}}}}}
Else {
$ACSCollector="No"
$ACSCollectorServiceAccount="n/a"
$ACSCollectorServiceStartMode="n/a"
$ACSCollectorLastUpdate="n/a"
$ACSCollectorVersion="n/a"
}
<# CODE_SECTION_29
Get RMS owner.
#>
$CodeSection="29"
$Connection=New-Object System.Data.SQLClient.SQLConnection
$Query="SELECT [PrincipalName] FROM [$OpsDbName].[dbo].[MTV_HealthService] WHERE IsRHS='1'"
$Connection.ConnectionString="Data Source=$OpsDbServer;Database=$OpsDbName;Trusted_Connection=True;"
$Connection.Open()
$Command=New-Object System.Data.SQLClient.SQLCommand
$Command.Connection=$Connection
$Command.CommandText=$Query
$Reader=$Command.ExecuteReader()
$Datatable=New-Object System.Data.DataTable
$Datatable.Load($Reader)
$RMSFqdn=$Datatable.PrincipalName
$Connection.Close() 
If($RMSFqdn -eq $ComputerFqdn) {
$RMS="Yes"
} Else {
$RMS="No"
}
} 
Else {
$MgmtServerInstallDirectory="n/a"
$MgmtServerLastUpdate="n/a"
$MgmtServerVersion="n/a"
$ConfigServiceAccount="n/a"
$ConfigServiceStartMode="n/a"
$DataAccessServiceAccount="n/a"
$DataAccessServiceStartMode="n/a"
$OpsDbName="n/a"
$OpsDbServer="n/a"
$DWDbName="n/a"
$DwDbServer="n/a"
$ACSCollector="No"
$ACSCollectorServiceAccount="n/a"
$ACSCollectorServiceStartMode="n/a"
$ACSCollectorLastUpdate="n/a"
$ACSCollectorVersion="n/a"
$RMS="n/a"
}
<#**************************************** GATEWAY SERVER SECTION ****************************************#>
If((Get-ItemProperty $SetupRegKey).MOMGatewayVersion) { # start gateway server section.
<# CODE_SECTION_30
Get gateway server install directory.
#>
$CodeSection="30"
$GatewayServerInstallDirectory=(Get-ItemProperty $SetupRegKey).InstallDirectory.TrimEnd("\")
$ValueToCheck="GatewayServerInstallDirectory"; CheckNull $GatewayServerInstallDirectory # Expect value.
<# CODE_SECTION_31
Get gateway server UR info
There are different files for different versions.
#>
$CodeSection="31"
$GatewayServerURFile="$GatewayServerInstallDirectory\HealthService.dll" # Should be on all versions. Best UR file for 2012 R2 (All URs), 2016 (UR2, UR4-9), 2019 UR1.
CheckFile $GatewayServerURFile # Alert if file doesn't exist.
If ($Script:FileExists -eq $True) {
$GatewayServerLastUpdate=$Script:FileLastAccessTime # Determines when UR was installed.
$GatewayServerVersion=$Script:FileVersion
If ($GatewayServerVersion -match "8.0.10970.0") {  # Best UR file for 2016 UR3.
$GatewayServerURFile="$GatewayServerInstallDirectory\MomWsManModules.dll"
CheckFile $GatewayServerURFile # Alert if file doesn't exist.
If ($Script:FileExists -eq $True){
$GatewayServerLastUpdate=$Script:FileLastAccessTime # Determines when UR was installed.
$GatewayServerVersion=$Script:FileVersion
}
} ElseIf ($GatewayServerVersion -match "8.0.13053.0") {  # Best UR file for 1801.
$GatewayServerURFile="$GatewayServerInstallDirectory\MOMAgentManagement.dll"
CheckFile $GatewayServerURFile # Alert if file doesn't exist.
If ($Script:FileExists -eq $True){
$GatewayServerLastUpdate=$Script:FileLastAccessTime # Determines when UR was installed.
$GatewayServerVersion=$Script:FileVersion
}
}
$ValueToCheck="GatewayServerLastUpdate"; CheckNull $GatewayServerLastUpdate # Expect value.
$ValueToCheck="GatewayServerVersion"; CheckNull $GatewayServerVersion # Expect value.
If ($Script:IsItNull -ne $True) {
Switch($GatewayServerVersion) {
# SCOM 2012 R2
"7.1.10184.0" {$GatewayServerVersion="2012 R2 RTM"; BREAK}
"7.1.10188.0" {$GatewayServerVersion="2012 R2 UR1"; BREAK}
"7.1.10195.0" {$GatewayServerVersion="2012 R2 UR2"; BREAK}
"7.1.10204.0" {$GatewayServerVersion="2012 R2 UR3"; BREAK}
"7.1.10211.0" {$GatewayServerVersion="2012 R2 UR4"; BREAK}
"7.1.10213.0" {$GatewayServerVersion="2012 R2 UR5"; BREAK}
"7.1.10218.0" {$GatewayServerVersion="2012 R2 UR6"; BREAK}
"7.1.10229.0" {$GatewayServerVersion="2012 R2 UR7"; BREAK}
"7.1.10241.0" {$GatewayServerVersion="2012 R2 UR8"; BREAK}
"7.1.10268.0" {$GatewayServerVersion="2012 R2 UR9"; BREAK}
"7.1.10285.0" {$GatewayServerVersion="2012 R2 UR11"; BREAK}
"7.1.10292.0" {$GatewayServerVersion="2012 R2 UR12"; BREAK}
"7.1.10302.0" {$GatewayServerVersion="2012 R2 UR13"; BREAK}
"7.1.10305.0" {$GatewayServerVersion="2012 R2 UR14"; BREAK}
# SCOM 2016
"8.0.10918.0" {$GatewayServerVersion="2016 RTM"; BREAK}
"8.0.10949.0" {$GatewayServerVersion="2016 UR2"; BREAK}
"8.0.10970.0" {$GatewayServerVersion="2016 UR3"; BREAK}
"8.0.10977.0" {$GatewayServerVersion="2016 UR4"; BREAK}		
"8.0.10990.0" {$GatewayServerVersion="2016 UR5"; BREAK}
"8.0.11004.0" {$GatewayServerVersion="2016 UR6"; BREAK}
"8.0.11025.0" {$GatewayServerVersion="2016 UR7"; BREAK}
"8.0.11037.0" {$GatewayServerVersion="2016 UR8"; BREAK}		
"8.0.11049.0" {$GatewayServerVersion="2016 UR9"; BREAK}		
"8.0.11057.0" {$GatewayServerVersion="2016 UR10"; BREAK} # Unverified. Hoping HealthService.dll gets updated.
# SCOM 1801
"8.0.13053.0" {$GatewayServerVersion="1801"; BREAK}		
"7.3.13261.0" {$GatewayServerVersion="1807"; BREAK} # yes this is the correct version even though the number is older.
# SCOM 2019
"10.19.10014.0" {$GatewayServerVersion="2019 RTM"; BREAK}
"10.19.10140.0" {$GatewayServerVersion="2019 UR1"; BREAK}
"10.19.10153.0" {$GatewayServerVersion="2019 UR2"; BREAK}
Default {
$Script:Message+="[CODE_SECTION_$CodeSection] Unknown gateway server version: $GatewayServerVersion.`n";
$GatewayServerVersion="Unknown version - $GatewayServerVersion"
}}}}
} # end big "if gateway server" section. 
Else
{ 
$GatewayServerInstallDirectory="n/a"
$GatewayServerLastUpdate="n/a"
$GatewayServerVersion="n/a"
#$GatewayMGCount="n/a"
#$GatewayMGFailovers="n/a"
}
<#**************************************** WEB CONSOLE SERVER SECTION ****************************************#>
$WebConsoleRegKey="HKLM:\SOFTWARE\Microsoft\System Center Operations Manager\12\Setup\WebConsole"
If(Test-Path $WebConsoleRegKey) {
<# CODE_SECTION_33
Get web console install directory.
#>
$CodeSection="33"
$WebConsoleInstallDirectory=(Get-ItemProperty $WebConsoleRegKey).InstallDirectory.TrimEnd("\")
$ValueToCheck="WebConsoleInstallDirectory"; CheckNull $WebConsoleInstallDirectory # Expect value.
<# CODE_SECTION_34
Get web console UR file info.
There are different files for different versions.
#>
$CodeSection="34"
$WebConsoleURFile="$WebConsoleInstallDirectory\WebHost\bin\Microsoft.EnterpriseManagement.Management.DataProviders.dll" # Best UR file for 2012 R2.
CheckFile $WebConsoleURFile NoAlert
If($script:FileVersion -match "7.1.1") {
$WebConsoleLastUpdate=$Script:FileLastAccessTime # Determines when UR was installed.
$WebConsoleVersion=$Script:FileVersion
}
$WebConsoleURFile="$WebConsoleInstallDirectory\WebHost\bin\Microsoft.EnterpriseManagement.Monitoring.DataProviders.dll" # Best UR file for 2016.
CheckFile $WebConsoleURFile NoAlert
If($script:FileVersion -match "7.2.1") {
$WebConsoleLastUpdate=$Script:FileLastAccessTime # Determines when UR was installed.
$WebConsoleVersion=$Script:FileVersion
}
$WebConsoleURFile="$WebConsoleInstallDirectory\WebHost\bin\Microsoft.Mom.Common.dll" # Best UR file for 1801.
CheckFile $WebConsoleURFile NoAlert
If($script:FileVersion -match "7.3.1") {
$WebConsoleLastUpdate=$Script:FileLastAccessTime # Determines when UR was installed.
$WebConsoleVersion=$Script:FileVersion
}
$WebConsoleURFile="$WebConsoleInstallDirectory\Dashboard\bin\Microsoft.EnterpriseManagement.OMDataService.dll" # Best UR file for 2019.
CheckFile $WebConsoleURFile NoAlert
If($script:FileVersion -match "10.19") {
$WebConsoleLastUpdate=$Script:FileLastAccessTime # Determines when UR was installed.
$WebConsoleVersion=$Script:FileVersion
}
$ValueToCheck="WebConsoleLastUpdate"; CheckNull $WebConsoleLastUpdate # Expect value.
$ValueToCheck="WebConsoleVersion"; CheckNull $WebConsoleVersion # Expect value.
If ($Script:IsItNull -ne $True) {
Switch($WebConsoleVersion) {
# SCOM 2012 R2
"7.1.10226.0" {$WebConsoleVersion="2012 R2 RTM"; BREAK}
"7.1.10226.1009" {$WebConsoleVersion="2012 R2 UR1"; BREAK}
"7.1.10226.1015" {$WebConsoleVersion="2012 R2 UR2"; BREAK}
"7.1.10226.1037" {$WebConsoleVersion="2012 R2 UR3"; BREAK}
"7.1.10226.1046" {$WebConsoleVersion="2012 R2 UR4"; BREAK}
"7.1.10226.1052" {$WebConsoleVersion="2012 R2 UR5"; BREAK}
"7.1.10226.1064" {$WebConsoleVersion="2012 R2 UR6"; BREAK}
"7.1.10226.1090" {$WebConsoleVersion="2012 R2 UR7"; BREAK}
"7.1.10226.1118" {$WebConsoleVersion="2012 R2 UR8"; BREAK}
"7.1.10226.1177" {$WebConsoleVersion="2012 R2 UR9"; BREAK}
"7.1.10226.1239" {$WebConsoleVersion="2012 R2 UR11"; BREAK}
"7.1.10226.1304" {$WebConsoleVersion="2012 R2 UR12"; BREAK}
"7.1.10226.1360" {$WebConsoleVersion="2012 R2 UR13"; BREAK}
"7.1.10226.1387" {$WebConsoleVersion="2012 R2 UR14"; BREAK}
# SCOM 2016
"7.2.11719.0" {$WebConsoleVersion="2016 RTM"; BREAK}
"7.2.11759.0" {$WebConsoleVersion="2016 UR1"; BREAK}
"7.2.11822.0" {$WebConsoleVersion="2016 UR2"; BREAK}
"7.2.11878.0" {$WebConsoleVersion="2016 UR3"; BREAK}
"7.2.11938.0" {$WebConsoleVersion="2016 UR4"; BREAK}		
"7.2.12016.0" {$WebConsoleVersion="2016 UR5"; BREAK}
"7.2.12066.0" {$WebConsoleVersion="2016 UR6"; BREAK}
"7.2.12150.0" {$WebConsoleVersion="2016 UR7"; BREAK}
"7.2.12213.0" {$WebConsoleVersion="2016 UR8"; BREAK}		
"7.2.12265.0" {$WebConsoleVersion="2016 UR9"; BREAK}		
"7.2.12324.0" {$WebConsoleVersion="2016 UR10"; BREAK}
# SCOM 1801
"7.3.13142.0" {$WebConsoleVersion="1801"; BREAK}		
"7.3.13261.0" {$WebConsoleVersion="7.3.13261.0 (1807"; BREAK} # this is how we id the 1807 patch on a web server.
# SCOM 2019
"10.19.10050.0" {$WebConsoleVersion="2019 RTM"; BREAK}
"10.19.10311.0" {$WebConsoleVersion="2019 UR1"; BREAK}
"10.19.10349.0" {$WebConsoleVersion="2019 UR1 Hotfix"; BREAK}
"10.19.10407.0" {$WebConsoleVersion="2019 UR2"; BREAK}
Default {
$Script:Message+="[CODE_SECTION_$CodeSection] Unknown web console version: $WebConsoleVersion.`n"; # Check #4. If previous 3 checks fail it must be a new version of the WebConsole. Generate warning so we know to update mp.
$WebConsoleVersion="Unknown version - $WebConsoleVersion"
}}}
<# CODE_SECTION_35
Get Authentication Mode.
#>
$CodeSection="35"
$AuthenticationMode=(Get-ItemProperty $WebConsoleRegKey).AUTHENTICATION_MODE
$ValueToCheck="AuthenticationMode"; CheckNull $AuthenticationMode # Expect value.
<# CODE_SECTION_36
Get DefaultServer.
#>
$CodeSection="36"
$DefaultServer=(Get-ItemProperty $WebConsoleRegKey).DEFAULT_SERVER
$ValueToCheck="DefaultServer"; CheckNull $DefaultServer # Expect value.
<# CODE_SECTION_37
Get WebConsoleUrl.
#>
$CodeSection="37"
$WebConsoleUrl=(Get-ItemProperty $WebConsoleRegKey).WEB_CONSOLE_URL
$ValueToCheck="WebConsoleUrl"; CheckNull $WebConsoleUrl # Expect value.
<# CODE_SECTION_38
Get ApmAdvisorUrl.
#>
$CodeSection="38"
$ApmAdvisorUrl=(Get-ItemProperty $WebConsoleRegKey).APM_ADVISOR_URL
$ValueToCheck="ApmAdvisorUrl"; CheckNull $ApmAdvisorUrl # Expect value.
<# CODE_SECTION_39
Get ApmDiagnosticsUrl.
#>
$CodeSection="39"
$ApmDiagnosticsUrl=(Get-ItemProperty $WebConsoleRegKey).APM_DIAGNOSTICS_URL
$ValueToCheck="ApmDiagnosticsUrl"; CheckNull $ApmDiagnosticsUrl # Expect value.
}
Else {
$WebConsoleInstallDirectory="n/a"
$WebConsoleLastUpdate="n/a"
$WebConsoleVersion="n/a"
$AuthenticationMode="n/a"
$DefaultServer="n/a"
$WebConsoleUrl="n/a"
$ApmAdvisorUrl="n/a"
$ApmDiagnosticsUrl="n/a"
}
<#**************************************** REPORT SERVER SECTION ****************************************#>
<# CODE_SECTION_40
Get report server install directory.
#>
$ReportServerRegKey="HKLM:\SOFTWARE\Microsoft\System Center Operations Manager\12\Reporting" # If this key exists it's a SCOM report server.
If(Test-Path $ReportServerRegKey) {
$CodeSection="40"
$ReportServerInstallDirectory=(Get-ItemProperty $ReportServerRegKey\..\Setup\Reporting).InstallDirectory.TrimEnd("\")
$ValueToCheck="ReportServerInstallDirectory"; CheckNull $ReportServerInstallDirectory # Expect value.
<# CODE_SECTION_41
Get report server UR info.
There are different files for different versions. 
#>
$CodeSection="41"
$ReportServerURFile="$ReportServerInstallDirectory\Microsoft.Mom.Common.dll" # Get SCOM version. Every RS has this file. Best file for 2012 R2 with no URs installed.
CheckFile $ReportServerURFile # Alert if file doesn't exist.
If ($Script:FileExists -eq $True) { # Check file versions to determine the right one to use.
If($Script:FileVersion -match "7.1.1") { # 2012 R2.
$ReportServerURFile="$ReportServerInstallDirectory\SDK Binaries\Microsoft.EnterpriseManagement.OperationsManager.dll" # If a 2012 R2 UR has been installed this file will exist.
CheckFile $ReportServerURFile NoAlert # Don't alert if file doesn't exist.
$ReportServerLastUpdate=$Script:FileLastAccessTime # Determines when UR was installed.
$ReportServerVersion=$Script:FileVersion
}
ElseIf (($Script:FileVersion -match "7.2.1") -or ($Script:FileVersion -match "7.3.1" )) {# 2016, 1801.
$ReportServerURFile="C:\Windows\Microsoft.NET\assembly\GAC_MSIL\Microsoft.EnterpriseManagement.OperationsManager\v4.0_7.0.5000.0__31bf3856ad364e35\Microsoft.EnterpriseManagement.OperationsManager.dll"
CheckFile $ReportServerURFile # Alert if file doesn't exist.
$ReportServerLastUpdate=$Script:FileLastAccessTime # Determines when UR was installed.
$ReportServerVersion=$Script:FileVersion
}
ElseIf ($Script:FileVersion -match "10.19") { # 2019.
$File1="C:\Windows\Microsoft.NET\assembly\GAC_MSIL\Microsoft.EnterpriseManagement.Core\v4.0_7.0.5000.0__31bf3856ad364e35\Microsoft.EnterpriseManagement.Core.dll" # RTM & UR1Hotfix. Created when RS installed.
CheckFile $File1 # Alert if file doesn't exist.
$ReportServerLastUpdate=$Script:FileLastAccessTime # Determines when UR was installed.
$ReportServerVersion=$Script:FileVersion
$File1Date=$Script:FileLastAccessTimeRaw
$File1Version=$Script:FileVersion
$File2="C:\Windows\Microsoft.NET\assembly\GAC_MSIL\Microsoft.EnterpriseManagement.OperationsManager\v4.0_7.0.5000.0__31bf3856ad364e35\Microsoft.EnterpriseManagement.OperationsManager.dll" # UR1, UR2.
CheckFile $File2 NoAlert # Don't alert if file doesn't exist.
If ($Script:FileExists -eq $True) {
$File2Date=$Script:FileLastAccessTimeRaw
$File2Version=$Script:FileVersion
If ($File1Date -lt $File2Date) { # If $File2Date is older than $File1Date it means UR1Hotfix has been installed.
$ReportServerLastUpdate=$Script:FileLastAccessTime # Determines when UR was installed.
$ReportServerVersion=$Script:FileVersion
}}}
$ValueToCheck="ReportServerLastUpdate"; CheckNull $ReportServerLastUpdate # Expect value.
$ValueToCheck="ReportServerVersion"; CheckNull $ReportServerVersion # Expect value.
If ($Script:IsItNull -ne $True) { # 
Switch($ReportServerVersion) {
# SCOM 2012 R2
"7.1.10226.0" {$ReportServerVersion="2012 R2 RTM"; BREAK}
"7.1.10226.1304" {$ReportServerVersion="2012 R2 UR12"; BREAK}
"7.1.10226.1360" {$ReportServerVersion="2012 R2 UR13"; BREAK}
"7.1.10226.1387" {$ReportServerVersion="2012 R2 UR14"; BREAK}
# SCOM 2016
"7.2.11719.0" {$ReportServerVersion="2016 RTM"; BREAK}
"7.2.12016.0" {$ReportServerVersion="2016 UR5"; BREAK}
"7.2.12066.0" {$ReportServerVersion="2016 UR6"; BREAK}
"7.2.12150.0" {$ReportServerVersion="2016 UR7"; BREAK}
"7.2.12213.0" {$ReportServerVersion="2016 UR8"; BREAK}		
"7.2.12265.0" {$ReportServerVersion="2016 UR9"; BREAK}		
"7.2.12324.0" {$ReportServerVersion="2016 UR10"; BREAK}
# SCOM 1801
"7.3.13142.0" {$ReportServerVersion="1801"; BREAK}		
"7.3.13261.0" {$ReportServerVersion="1807"; BREAK}	
# SCOM 2019
"10.19.1032.0" {$ReportServerVersion="2019 RTM"; BREAK}
"10.19.10311.0" {$ReportServerVersion="2019 UR1"; BREAK}
"10.19.1035.82" {$ReportServerVersion="2019 UR1 Hotfix"; BREAK}
"10.19.1035.100" {$ReportServerVersion="2019 UR2"; BREAK} # Microsoft.EnterpriseManagement.Core.dll. Adding 2 values for UR2 in case date compare gets weird.
"10.19.10407.0" {$ReportServerVersion="2019 UR2"; BREAK} # Microsoft.EnterpriseManagement.OperationsManager.dll.
Default {
$Script:Message+="[CODE_SECTION_$CodeSection] Unknown report server version: $ReportServerVersion.`n";
$ReportServerVersion="Unknown version - $ReportServerVersion"  
}}}
}
<# CODE_SECTION_42
Get ReportServerDwDbServer.
#>
$CodeSection="42"
$ReportServerDwDbServer=(Get-ItemProperty $ReportServerRegKey).DWDBInstance
$ValueToCheck="ReportServerDwDbServer"; CheckNull $ReportServerDwDbServer # Expect value.
<# CODE_SECTION_43
Get ReportServerDWDBName.
#>
$CodeSection="43"
$ReportServerDWDBName=(Get-ItemProperty $ReportServerRegKey).DWDBName
$ValueToCheck="ReportServerDWDBName"; CheckNull $ReportServerDWDBName # Expect value.
<# CODE_SECTION_44
Get ReportServerUrl.
#>
$CodeSection="44"
$ReportServerUrl=(Get-ItemProperty $ReportServerRegKey).ReportingServerUrl
$ValueToCheck="ReportServerUrl"; CheckNull $ReportServerUrl # Expect value.
<# CODE_SECTION_45
Get SRSInstance.
#>
$CodeSection="45"
$SRSInstance=(Get-ItemProperty $ReportServerRegKey).SRSInstance
$ValueToCheck="SRSInstance"; CheckNull $SRSInstance # Expect value.
<# CODE_SECTION_46
Get report service account and start mode.
Using the registry to get report server service info is unreliable because info returned by different SQL versions and named instances is inconsistent.
#>
$CodeSection="46"
$ReportServerService=Get-WmiObject Win32_Service -Filter "DisplayName like 'SQL Server Reporting Services%'" # Confirmed this works on SQL 2012SP4, 2017.
$ReportServerServiceAccount=$ReportServerService.StartName
$ReportServerServiceStartMode=$ReportServerService.StartMode
$ValueToCheck="ReportServerServiceAccount"; CheckNull $ReportServerServiceAccount # Expect value.
$ValueToCheck="ReportServerServiceStartMode"; CheckNull $ReportServerServiceStartMode # Expect value.
}
Else {
$ReportServerInstallDirectory="n/a"
$ReportServerLastUpdate="n/a"
$ReportServerVersion="n/a"
$ReportServerDwDbServer="n/a"
$ReportServerDWDBName="n/a"
$ReportServerUrl="n/a"
$SRSInstance="n/a"
$ReportServerServiceAccount="n/a"
$ReportServerServiceStartMode="n/a"
}
<#**************************************** CONSOLE SECTION ****************************************#>
<# CODE_SECTION_47
Get console directory.
#>
$CodeSection="47"
$ConsoleRegKey="HKLM:\SOFTWARE\Microsoft\System Center Operations Manager\12\Setup\Console" # If this key exists the console is installed.
If(Test-Path $ConsoleRegKey) {
$ConsoleInstallDirectory=(Get-ItemProperty $ConsoleRegKey).InstallDirectory.TrimEnd("\")
$ValueToCheck="ConsoleInstallDirectory"; CheckNull $ConsoleInstallDirectory # Expect value.
<# CODE_SECTION_48
Get console UR info.
#>
$CodeSection="48"
$ConsoleURFile="$ConsoleInstallDirectory\Tools\TMF\OMTraceTMFVer.Dll" # Best file for UR info.
CheckFile $ConsoleURFile # Alert if file doesn't exist.
If ($Script:FileExists -eq $True) {
$ConsoleLastUpdate=$Script:FileLastAccessTime # Determines when UR was installed.
$ValueToCheck="ConsoleLastUpdate"; CheckNull $ConsoleLastUpdate # Expect value.
$ConsoleVersion=$Script:FileVersion
$ValueToCheck="ConsoleVersion"; CheckNull $ConsoleVersion # Expect value.
If ($Script:IsItNull -ne $True) { # 
Switch($ConsoleVersion) {
# SCOM 2012
"7.0.9538.0" {$ConsoleVersion="2012 SP1"; BREAK}
# SCOM 2012 R2
"7.1.10226.0" {$ConsoleVersion="2012 R2 RTM"; BREAK}
"7.1.10226.1009" {$ConsoleVersion="2012 R2 UR1"; BREAK}
"7.1.10226.1015" {$ConsoleVersion="2012 R2 UR2"; BREAK}
"7.1.10226.1037" {$ConsoleVersion="2012 R2 UR3"; BREAK}
"7.1.10226.1046" {$ConsoleVersion="2012 R2 UR4"; BREAK}
"7.1.10226.1064" {$ConsoleVersion="2012 R2 UR6"; BREAK}
"7.1.10226.1090" {$ConsoleVersion="2012 R2 UR7"; BREAK}
"7.1.10226.1118" {$ConsoleVersion="2012 R2 UR8"; BREAK}
"7.1.10226.1177" {$ConsoleVersion="2012 R2 UR9"; BREAK}
"7.1.10226.1239" {$ConsoleVersion="2012 R2 UR11"; BREAK}
"7.1.10226.1304" {$ConsoleVersion="2012 R2 UR12"; BREAK}
"7.1.10226.1360" {$ConsoleVersion="2012 R2 UR13"; BREAK}
"7.1.10226.1387" {$ConsoleVersion="2012 R2 UR14"; BREAK}
# SCOM 2016
"7.2.11719.0" {$ConsoleVersion="2016 RTM"; BREAK}
"7.2.11759.0" {$ConsoleVersion="2016 UR1"; BREAK}
"7.2.11822.0" {$ConsoleVersion="2016 UR2"; BREAK}
"7.2.11878.0" {$ConsoleVersion="2016 UR3"; BREAK}
"7.2.11938.0" {$ConsoleVersion="2016 UR4"; BREAK}		
"7.2.12016.0" {$ConsoleVersion="2016 UR5"; BREAK}
"7.2.12066.0" {$ConsoleVersion="2016 UR6"; BREAK}
"7.2.12150.0" {$ConsoleVersion="2016 UR7"; BREAK}
"7.2.12213.0" {$ConsoleVersion="2016 UR8"; BREAK}		
"7.2.12265.0" {$ConsoleVersion="2016 UR9"; BREAK}		
"7.2.12324.0" {$ConsoleVersion="2016 UR10"; BREAK}
# SCOM 1801
"7.3.13142.0" {$ConsoleVersion="1801"; BREAK}		
"7.3.13261.0" {$ConsoleVersion="1807"; BREAK}	
# SCOM 2019
"10.19.10050.0" {$ConsoleVersion="2019 RTM"; BREAK}
"10.19.10311.0" {$ConsoleVersion="2019 UR1"; BREAK}
"10.19.10349.0" {$ConsoleVersion="2019 UR1 Hotfix"; BREAK}
"10.19.10407.0" {$ConsoleVersion="2019 UR2"; BREAK}
Default {
$Script:Message+="[CODE_SECTION_$CodeSection] Unknown console version: $ConsoleVersion.`n"
$ConsoleVersion="Unknown version - $ConsoleVersion"
}}}}
} Else {
$ConsoleInstallDirectory="n/a"
$ConsoleLastUpdate="n/a"
$ConsoleVersion="n/a"
}
<#**************************************** TESTING SECTION ****************************************#>
<# FOR TESTING
write-host "OperatingSystem: $OperatingSystem"
write-host "Product: $Product"
write-host "AgentInstallDirectory: $AgentInstallDirectory"
write-host "AgentLastUpdate: $AgentLastUpdate"
write-host "AgentVersion: $AgentVersion"
#write-host "AgentMGCount: $AgentMGCount"
#write-host "AgentMGFailovers: $AgentMGFailovers"
write-host "MGCount: $MGCount"
write-host "MGNames: $MGNames"
write-host "HealthServiceAccount: $HealthServiceAccount"
write-host "HealthServiceStartMode: $HealthServiceStartMode"
write-host "CertificateExpiry: $CertificateExpiry"
write-host "ADIntegration: $ADIntegration"
write-host "APMInstalled: $APMInstalled"
write-host "APMServiceAccount: $APMServiceAccount"
write-host "APMServiceStartMode: $APMServiceStartMode"
write-host "ACSForwarderServiceAccount: $ACSForwarderServiceAccount"
write-host "ACSForwarderServiceStartMode: $ACSForwarderServiceStartMode"
write-host "TLS12: $TLS12"
write-host "LAWorkspaceCount: $LAWorkspaceCount"
write-host "LAWorkspaces: $LAWorkspaces"
write-host "LAProxyUrl: $LAProxyUrl"
write-host "LAProxyUsername: $LAProxyUsername"
write-host "ComputerType: $ComputerType"
write-host "MgmtServerInstallDirectory: $MgmtServerInstallDirectory"
write-host "MgmtServerLastUpdate: $MgmtServerLastUpdate"
write-host "MgmtServerVersion: $MgmtServerVersion"
write-host "ConfigServiceAccount: $ConfigServiceAccount"
write-host "ConfigServiceStartMode: $ConfigServiceStartMode"
write-host "DataAccessServiceAccount: $DataAccessServiceAccount"
write-host "DataAccessServiceStartMode: $DataAccessServiceStartMode"
write-host "OpsDbName: $OpsDbName"
write-host "OpsDbServer: $OpsDbServer"
write-host "DWDbName: $DWDbName"
write-host "DwDbServer: $DwDbServer"
write-host "ACSCollector: $ACSCollector"
write-host "ACSCollectorServiceAccount: $ACSCollectorServiceAccount"
write-host "ACSCollectorServiceStartMode: $ACSCollectorServiceStartMode"
write-host "ACSCollectorLastUpdate: $ACSCollectorLastUpdate"
write-host "ACSCollectorVersion: $ACSCollectorVersion"
write-host "RMS: $RMS"
write-host "GatewayServerInstallDirectory: $GatewayServerInstallDirectory"
write-host "GatewayServerLastUpdate: $GatewayServerLastUpdate"
write-host "GatewayServerVersion: $GatewayServerVersion"
#write-host "GatewayMGCount: $GatewayMGCount"
#write-host "GatewayMGFailovers: $GatewayMGFailovers"
write-host "WebConsoleInstallDirectory: $WebConsoleInstallDirectory"
write-host "WebConsoleLastUpdate: $WebConsoleLastUpdate"
write-host "WebConsoleVersion: $WebConsoleVersion"
write-host "AuthenticationMode: $AuthenticationMode"
write-host "DefaultServer: $DefaultServer"
write-host "WebConsoleUrl: $WebConsoleUrl"
write-host "ApmAdvisorUrl: $ApmAdvisorUrl"
write-host "ApmDiagnosticsUrl: $ApmDiagnosticsUrl"
write-host "ReportServerInstallDirectory: $ReportServerInstallDirectory"
write-host "ReportServerLastUpdate: $ReportServerLastUpdate"
write-host "ReportServerVersion: $ReportServerVersion"
write-host "ReportServerDwDbServer: $ReportServerDwDbServer"
write-host "ReportServerDWDBName: $ReportServerDWDBName"
write-host "ReportServerUrl: $ReportServerUrl"
write-host "SRSInstance: $SRSInstance"
write-host "ReportServerServiceAccount: $ReportServerServiceAccount"
write-host "ReportServerServiceStartMode: $ReportServerServiceStartMode"
write-host "ConsoleInstallDirectory: $ConsoleInstallDirectory"
write-host "ConsoleLastUpdate: $ConsoleLastUpdate"
write-host "ConsoleVersion: $ConsoleVersion"
Write-Host "PSVersion: $PSVersion" # Not returned as discovery data. Only used in events.
#>
<#**************************************** ADD DISCOVERY DATA SECTION ****************************************#>
$Instance=$DiscoveryData.CreateClassInstance("$MPElement[Name='SCOM.Class.URWindowsComputer']$")
$Instance.AddProperty("$MPElement[Name='Windows!Microsoft.Windows.Computer']/PrincipalName$", $ComputerName)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/OperatingSystem$", $OperatingSystem)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/Product$", $Product)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/AgentInstallDirectory$", $AgentInstallDirectory)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/AgentLastUpdate$", $AgentLastUpdate)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/AgentVersion$", $AgentVersion)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/MGCount$", $MGCount)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/MGNames$", $MGNames)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/HealthServiceAccount$", $HealthServiceAccount)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/HealthServiceStartMode$", $HealthServiceStartMode)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/CertificateExpiry$", $CertificateExpiry)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/ADIntegration$", $ADIntegration)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/APMInstalled$", $APMInstalled)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/APMServiceAccount$", $APMServiceAccount)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/APMServiceStartMode$", $APMServiceStartMode)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/ACSForwarderServiceAccount$", $ACSForwarderServiceAccount)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/ACSForwarderServiceStartMode$", $ACSForwarderServiceStartMode)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/TLS12$", $TLS12)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/LAWorkspaceCount$", $LAWorkspaceCount)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/LAWorkspaces$", $LAWorkspaces)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/LAProxyUrl$", $Script:LAProxyUrl)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/LAProxyUsername$", $Script:LAProxyUsername)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/ComputerType$", $ComputerType)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/MgmtServerInstallDirectory$", $MgmtServerInstallDirectory)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/MgmtServerLastUpdate$", $MgmtServerLastUpdate)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/MgmtServerVersion$", $MgmtServerVersion)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/ConfigServiceAccount$", $ConfigServiceAccount)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/ConfigServiceStartMode$", $ConfigServiceStartMode)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/DataAccessServiceAccount$", $DataAccessServiceAccount)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/DataAccessServiceStartMode$", $DataAccessServiceStartMode)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/OpsDbName$", $OpsDbName)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/OpsDbServer$", $OpsDbServer)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/DWDbName$", $DWDbName)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/DwDbServer$", $DwDbServer)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/ACSCollector$", $ACSCollector)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/ACSCollectorServiceAccount$", $ACSCollectorServiceAccount)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/ACSCollectorServiceStartMode$", $ACSCollectorServiceStartMode)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/ACSCollectorLastUpdate$", $ACSCollectorLastUpdate)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/ACSCollectorVersion$", $ACSCollectorVersion)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/RMS$", $RMS)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/GatewayServerInstallDirectory$", $GatewayServerInstallDirectory)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/GatewayServerLastUpdate$", $GatewayServerLastUpdate)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/GatewayServerVersion$", $GatewayServerVersion)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/WebConsoleInstallDirectory$", $WebConsoleInstallDirectory)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/WebConsoleLastUpdate$", $WebConsoleLastUpdate)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/WebConsoleVersion$", $WebConsoleVersion)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/AuthenticationMode$", $AuthenticationMode)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/DefaultServer$", $DefaultServer)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/WebConsoleUrl$", $WebConsoleUrl)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/ApmAdvisorUrl$", $ApmAdvisorUrl)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/ApmDiagnosticsUrl$", $ApmDiagnosticsUrl)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/ReportServerInstallDirectory$", $ReportServerInstallDirectory)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/ReportServerLastUpdate$", $ReportServerLastUpdate)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/ReportServerVersion$", $ReportServerVersion)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/ReportServerDwDbServer$", $ReportServerDwDbServer)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/ReportServerDWDBName$", $ReportServerDWDBName)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/ReportServerUrl$", $ReportServerUrl)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/SRSInstance$", $SRSInstance)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/ReportServerServiceAccount$", $ReportServerServiceAccount)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/ReportServerServiceStartMode$", $ReportServerServiceStartMode)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/ConsoleInstallDirectory$", $ConsoleInstallDirectory)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/ConsoleLastUpdate$", $ConsoleLastUpdate)
$Instance.AddProperty("$MPElement[Name='SCOM.Class.URWindowsComputer']/ConsoleVersion$", $ConsoleVersion)
$Instance.AddProperty("$MPElement[Name='System!System.Entity']/DisplayName$", $ComputerName)
$DiscoveryData.AddInstance($Instance)
# Submit discovery data back to Operations Manager and complete the script.
$DiscoveryData
<# FOR TESTING
$ObjMomApi.Return($DiscoveryData)
#>
LogAndQuit
}
Catch
{
TerminatingError
}
}
GetWindowsInventory -SourceId $SourceId -ManagedEntityId $ManagedEntityId -ComputerName $ComputerName # Need this to pass params in properly.
# End Windows discovery
]]>
</ScriptBody>
<Parameters>
<Parameter>
<Name>SourceId</Name>
<Value>$MPElement$</Value>
</Parameter>
<Parameter>
<Name>ManagedEntityId</Name>
<Value>$Target/Id$</Value>
</Parameter>
<Parameter>
<Name>ComputerName</Name>
<!--
2022.5.19
-Added "Host" to this line after changing discovery target to Microsoft.SystemCenter.HealthService.
 -->
<Value>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Value>
</Parameter>
</Parameters>
<TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
</DataSource>
</MemberModules>
<Composition>
<Node ID="DS" />
</Composition>
</Composite>
</ModuleImplementation>
<OutputType>System!System.Discovery.Data</OutputType>
</DataSourceModuleType>
<!--**************************************** ALERT MANAGEMENT SOURCE MODULE ****************************************-->
<DataSourceModuleType ID="SCOM.DSM.URAlertManagement" Accessibility="Public" Batching="false">
<Configuration>
<IncludeSchemaTypes>
<SchemaType>System!System.ExpressionEvaluatorSchema</SchemaType>
</IncludeSchemaTypes>
<xsd:element name="IntervalSeconds" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
</Configuration>
<OverrideableParameters>
<OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
<OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
</OverrideableParameters>
<ModuleImplementation Isolation="Any">
<Composite>
<MemberModules>
<DataSource ID="DS" TypeID="System!System.Scheduler">
<Scheduler>
<SimpleReccuringSchedule>
<Interval Unit="Seconds">$Config/IntervalSeconds$</Interval>
<SyncTime>$Config/SyncTime$</SyncTime>
</SimpleReccuringSchedule>
<ExcludeDates />
</Scheduler>
</DataSource>
</MemberModules>
<Composition>
<Node ID="DS" />
</Composition>
</Composite>
</ModuleImplementation>
<OutputType>System!System.TriggerData</OutputType>
</DataSourceModuleType>
<!--**************************************** MP BACKUP DATA SOURCE MODULE ****************************************-->
<DataSourceModuleType ID="SCOM.DSM.URMpBackup" Accessibility="Public" Batching="false">
<Configuration>
<IncludeSchemaTypes>
<SchemaType>System!System.ExpressionEvaluatorSchema</SchemaType>
</IncludeSchemaTypes>
<xsd:element name="IntervalSeconds" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
</Configuration>
<OverrideableParameters>
<OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
<OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
</OverrideableParameters>
<ModuleImplementation Isolation="Any">
<Composite>
<MemberModules>
<DataSource ID="DS" TypeID="System!System.Scheduler">
<Scheduler>
<SimpleReccuringSchedule>
<Interval Unit="Seconds">$Config/IntervalSeconds$</Interval>
<SyncTime>$Config/SyncTime$</SyncTime>
</SimpleReccuringSchedule>
<ExcludeDates />
</Scheduler>
</DataSource>
</MemberModules>
<Composition>
<Node ID="DS" />
</Composition>
</Composite>
</ModuleImplementation>
<OutputType>System!System.TriggerData</OutputType>
</DataSourceModuleType>
<!--**************************************** MG REPORT DATA SOURCE MODULE ****************************************-->
<DataSourceModuleType ID="SCOM.URMgReport" Accessibility="Public" Batching="false">
<Configuration>
<IncludeSchemaTypes>
<SchemaType>System!System.ExpressionEvaluatorSchema</SchemaType>
</IncludeSchemaTypes>
<xsd:element name="IntervalSeconds" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
</Configuration>
<OverrideableParameters>
<OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
<OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
</OverrideableParameters>
<ModuleImplementation Isolation="Any">
<Composite>
<MemberModules>
<DataSource ID="DS" TypeID="System!System.Scheduler">
<Scheduler>
<SimpleReccuringSchedule>
<Interval Unit="Seconds">$Config/IntervalSeconds$</Interval>
<SyncTime>$Config/SyncTime$</SyncTime>
</SimpleReccuringSchedule>
<ExcludeDates />
</Scheduler>
</DataSource>
</MemberModules>
<Composition>
<Node ID="DS" />
</Composition>
</Composite>
</ModuleImplementation>
<OutputType>System!System.TriggerData</OutputType>
</DataSourceModuleType>
<!--**************************************** Run command WRITE ACTION MODULE ****************************************-->
<WriteActionModuleType ID="SCOM.WAM.RunCommand" Accessibility="Internal" Batching="false">
<Configuration>
<xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element minOccurs="1" name="RunCommand" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
</Configuration>
<OverrideableParameters>
<OverrideableParameter ID="RunCommand" Selector="$Config/RunCommand$" ParameterType="string" />
<OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
</OverrideableParameters>
<ModuleImplementation Isolation="Any">
<Composite>
<MemberModules>
<WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
<ScriptName>SCOM.RunCommand.ps1</ScriptName>
<ScriptBody><![CDATA[
Param ($RunCommand)
$ComputerFqdn=([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname
Write-Host "====================================="
Write-Host "Task: Run command"
Write-Host "Computer: $ComputerFqdn"
Write-Host "====================================="
Write-Host
If ([string]::IsNullOrEmpty($RunCommand)) {
Write-Host "Command entered: Enter a command to run."
} else {
$Output=cmd /c $RunCommand
Write-Host "Command entered: $RunCommand"
Write-Host "Command output below:"
Write-Host
$Output
}
]]>
</ScriptBody>
<Parameters>
<Parameter>
<Name>RunCommand</Name>
<Value>$Config/RunCommand$</Value>
</Parameter>
</Parameters>
<TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
</WriteAction>
</MemberModules>
<Composition>
<Node ID="PSWA" />
</Composition>
</Composite>
</ModuleImplementation>
<OutputType>System!System.BaseData</OutputType>
<InputType>System!System.BaseData</InputType>
</WriteActionModuleType>
<!--**************************************** REMOVE MANAGEMENT GROUP WRITE ACTION MODULE ****************************************-->
<WriteActionModuleType ID="SCOM.WAM.URRemoveMgmtGroup" Accessibility="Internal" Batching="false">
<Configuration>
<xsd:element minOccurs="1" name="ManagementGroups" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema"/>
<xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema"/>
</Configuration>
<OverrideableParameters>
<OverrideableParameter ID="ManagementGroups" Selector="$Config/ManagementGroups$" ParameterType="string"/>
<OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int"/>
</OverrideableParameters>
<ModuleImplementation Isolation="Any">
<Composite>
<MemberModules>
<WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
<ScriptName>SCOM.RemoveMgmtGroup.ps1</ScriptName>
<ScriptBody>
<![CDATA[
Param($ManagementGroups)
Function Quit {
$Global:Output
}
Function RemoveItem {
Param($Item,$ItemType)
Try {
If (Test-Path -Path $Item) {
Remove-Item -Path $Item -Recurse -Force
$Global:Output+="[INFO] Removed $ItemType $Item`n"
}}
Catch {
"[ERROR]" + $_.Exception.Message
}}
Function RunScript {
Try {
$ErrorActionPreference="Continue"
$ComputerFqdn=([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname
$PSVersion=$PSVersionTable.PSVersion
$PSMajor=$PSVersion.Major
$PSMinor=$PSVersion.Minor
$PSVersion="$PSMajor.$PSMinor"
[int]$Count=0
$Global:Output+="Task: Remove management group`n"
$Global:Output+="Computer: $ComputerFqdn`n"
$Global:Output+="PowerShell Version: $PSVersion`n`n"
If ([string]::IsNullOrEmpty($ManagementGroups)) {
$Global:Output+="[WARNING] Missing parameter. Enter a comma separated list of management groups to remove.`n"
Quit
} else {
$ObjAgentConfig=New-Object -ComObject AgentConfigManager.MgmtSvcCfg
$RestartHealthService=$null
$SetupRegKey=Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Microsoft Operations Manager\3.0\Setup"
If($SetupRegKey.MOMGatewayVersion) {
$Global:Output+="[WARNING] This script cannot run on gateway servers."
} ElseIf($SetupRegKey.ServerVersion) {
$Global:Output+="[WARNING] This script cannot run on management servers."
} Else {
# Remove management group.
$MgmtGroups=$ObjAgentConfig.GetManagementGroups() | select managementGroupName
$ManagementGroups=$ManagementGroups.Split(",")
$ManagementGroups | ForEach-Object {
$MGName=$_
foreach ($i in $MgmtGroups) { # Had to do it this way because PowerShell v2 can't read the array using 'select-string -inputobject'.
If ($MGName -eq $i.managementGroupName) {
$Count+=1
$ObjAgentConfig.RemoveManagementGroup("$MGName")
$Global:Output+="[INFO] Removed management group '$MGName' from Control Panel applet.`n"
$RestartHealthService="Yes"
}}}
# Bounce HealthService. Need to do this before removing folders/reg key otherwise it re-creates them.
If ($RestartHealthService -eq "Yes") {
$Global:Output+="[INFO] Restarting HealthService.`n"
$Command="Restart-Service HealthService"
$processInfo = ([wmiclass]"root\cimv2:Win32_ProcessStartup").CreateInstance()
$processInfo.ShowWindow = 0
$processInfo.CreateFlags = 16777216
([wmiclass]"root\cimv2:Win32_Process").Create("powershell.exe $Command") | out-null
}
# Folder/reg clean up bit.
$ManagementGroups | ForEach-Object {
$MGName=$_
$InstallDirectory=$SetupRegKey.InstallDirectory
$MGNameFolder="$InstallDirectory`Health Service State\Connector Configuration Cache\$MGName"
$MGNameReg="HKLM:\SOFTWARE\Microsoft\Microsoft Operations Manager\3.0\Agent Management Groups\$MGName"
RemoveItem -Item $MGNameFolder -ItemType "folder"
RemoveItem -Item $MGNameReg -ItemType "reg key"
}
$Global:Output+="[INFO] End of script. $Count management group(s) removed."
}
Quit
}}
Catch {
"[ERROR] " + $_.Exception.Message
}}
RunScript -ManagementGroups $ManagementGroups
]]>
</ScriptBody>
<Parameters>
<Parameter>
<Name>ManagementGroups</Name>
<Value>$Config/ManagementGroups$</Value>
</Parameter>
</Parameters>
<TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
</WriteAction>
</MemberModules>
<Composition>
<Node ID="PSWA"/>
</Composition>
</Composite>
</ModuleImplementation>
<OutputType>System!System.BaseData</OutputType>
<InputType>System!System.BaseData</InputType>
</WriteActionModuleType>
<!--**************************************** DAILY REPORT WRITE ACTION MODULE ****************************************-->
<WriteActionModuleType ID="SCOM.WAM.URDailyReport" Accessibility="Internal" Batching="false">
<Configuration>
<xsd:element minOccurs="1" name="EmailFromAddress" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element minOccurs="1" name="EmailToAddress" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element minOccurs="1" name="EmailServer" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element minOccurs="1" name="EmailPort" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element minOccurs="1" name="Identifier" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
</Configuration>
<OverrideableParameters>
<OverrideableParameter ID="EmailFromAddress" Selector="$Config/EmailFromAddress$" ParameterType="string" />
<OverrideableParameter ID="EmailToAddress" Selector="$Config/EmailToAddress$" ParameterType="string" />
<OverrideableParameter ID="EmailServer" Selector="$Config/EmailServer$" ParameterType="string" />
<OverrideableParameter ID="EmailPort" Selector="$Config/EmailPort$" ParameterType="string" />
<OverrideableParameter ID="Identifier" Selector="$Config/Identifier$" ParameterType="string" />
<OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
</OverrideableParameters>
<ModuleImplementation Isolation="Any">
<Composite>
<MemberModules>
<WriteAction ID="WA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
<ScriptName>SCOM.DailyReport.ps1</ScriptName>
<ScriptBody><![CDATA[
# Start Daily Report
Param ($EmailFromAddress, $EmailToAddress, $EmailServer, $EmailPort, $Identifier)
$Global:Name
$Global:Alert_Count
$Global:Alerts
$Global:EmailBody
$Global:EmailFromAddress
$Global:EmailToAddress
$Global:EmailServer
$Global:EmailPort
$Global:Identifier
<#**************************************** FUNCTION: SendEmail ****************************************#>
Function SendEmail ($EmailFromAddress, $EmailToAddress, $EmailServer, $EmailPort) {
[string[]]$EmailToAddress=$EmailToAddress.split(',') # need this so we can send to multiple users.
Send-MailMessage -From $EmailFromAddress -To $EmailToAddress -Subject "$Identifier - SCOM Daily Report [SEC=OFFICIAL:Sensitive]" -Body "$EmailBody" -BodyAsHtml -SmtpServer $EmailServer -Port $EmailPort
}
<#**************************************** FUNCTION: LogAndQuit ****************************************#>
Function LogAndQuit {
If ($Script:CountError -gt 0) {
$EventId=17620 # error
$EventLevel=2
} Else {
$Script:CountError=0 # If no errors set this value so it appears in the event.
$EventId=17619 # success
$EventLevel=0
}
# Use MOMScriptAPI.LogScriptEvent method to log events because Write-EventLog doesn't work on new OSs.
$ObjMomApi.LogScriptEvent("SCOM.DailyReport.ps1", $EventId, $EventLevel, "Daily report script executed.`nWorkflow Name: SCOM.Rule.DailyReport`nManagement Pack: SCOM.UpdateRollup (2023.3.21.0)`nPowerShell Version: $PSVersion`nIssues Detected: $Script:CountError`n$Script:Message") # $Error dumps errors into the event.
}
<#**************************************** FUNCTION: TerminatingError ****************************************#>
Function TerminatingError
{
$script:CountError+=1
$script:Message+="[CODE_SECTION_$CodeSection] A terminating error occurred. Error output: (" + $_.Exception.Message + ").`n"
LogAndQuit
}
<#**************************************** FUNCTION: SQLQuery ****************************************#>
Function SQLQuery ($Script:DbServer,$Script:DbName,$Script:DbQuery) {
$Connection=New-Object System.Data.SQLClient.SQLConnection
$Connection.ConnectionString="Data Source=$DbServer;Database=$DbName;Trusted_Connection=True;"
$Connection.Open()
$Command=New-Object System.Data.SQLClient.SQLCommand
$Command.Connection=$Connection
$Command.CommandText=$DbQuery
$Reader=$Command.ExecuteReader()
$Script:Datatable=New-Object System.Data.DataTable
$Script:Datatable.Load($Reader)
$Connection.Close() 
}
<#**************************************** FUNCTION: DailyReport ****************************************#>
Function DailyReport {
$ErrorActionPreference="SilentlyContinue"
Try {
<# FOR TESTING
$Error.Clear()
$EmailFromAddress="add_address"
$EmailToAddress="add_address"
$EmailServer="add_server"
$EmailPort="add_port"
$Identifier="add_Identifier"
#>
<# CODE_SECTION_1
Load things we'll need.
#>
$CodeSection="1"
$Start=(Get-Date -format f)
# ? $User=[System.Security.Principal.WindowsIdentity]::GetCurrent().Name
$ObjMomApi=New-Object -comObject 'MOM.ScriptAPI' # MOMScriptAPI object.
$SetupRegKey="HKLM:\SOFTWARE\Microsoft\Microsoft Operations Manager\3.0\Setup" # Get db info so we can connect.
$Script:OpsDbName=(Get-ItemProperty $SetupRegKey).DatabaseName
$Script:OpsDbServer=(Get-ItemProperty $SetupRegKey).DatabaseServerName
$Script:DWDbName=(Get-ItemProperty $SetupRegKey).DataWarehouseDBName
$Script:DwDbServer=(Get-ItemProperty $SetupRegKey).DataWarehouseDBServerName
<# CODE_SECTION_2.
Get powershell version.
This is shown in events to assist troubleshooting if powershell doesn't play nice.
#>
$CodeSection="2"
$PSVersion=$PSVersionTable.PSVersion
[string]$PSMajor=$PSVersion.Major
[string]$PSMinor=$PSVersion.Minor
$PSVersion=$PSMajor + "." + $PSMinor
<# CODE_SECTION_3
17.12.2021 - Not using this.
Set common variables.
$CodeSection="3"
$ComputerFqdn=([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname
#>
<# CODE_SECTION_4
17.12.2021 - Not using this.
Load SCOM module.
$CodeSection="4"
$PowerShellInstallDirectory=(Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\System Center Operations Manager\12\Setup\Powershell\V2").InstallDirectory
Import-module $PowerShellInstallDirectory`OperationsManager
New-DefaultManagementGroupConnection
$MgName=(Get-SCOMManagementGroup).Name
#>
<# CODE_SECTION_5
Build html/css for report.
#>
$CodeSection="5"
$Head=@"
<style>
h1 {
font-size: 30px;
color: #34568B;
}
h2 {
font-size: 20px;
color: #34568B;
}
h3 {
font-size: 15px;
color: #34568B;
}
h4 {
font-size: 12px;
color: #34568B;
}
h1, h2, h3, h4 { /*common settings for h1, h2*/
font-family: Arial;
text-align: left;
}
th {
text-align: center;
font-size: 12px; /*header font size.*/
background-color: #34568B;
color: white; /*font colour*/
padding: 5px 5px; /*padding */
font-weight: normal; /*remove bold heading*/
}
td {
font-size: 11px; /*row font size.*/
color: #34568B;
text-align: left;
padding: 2px 4px; /*This adds more space between columns. 1st digit=row height, 2nd digit=row width.*/
}
table {
white-space:nowrap;
border-collapse: collapse;
/* not using - border: 1px solid #F2F2F2;
/*width: 100%; /*each table will use x% screen width. Not using.*/
}
th, td { /*common settings for table header and table data.*/
font-family: Arial;
border: 1px solid #8B9BB4; /* table border colour */
}
tr:nth-child(even) 
{background-color: #34568B;} /*not sure what this does but you need it or it breaks line "This report was generated on..."*/
p {
font-family: Arial;
font-size: 11px;
color: #34568B
}
#CreationDate {
font-family: Arial;
color: orange;
font-size: 12px;
}
.Info {
color: #F7F9F9;
background-color: #4CAF50;
text-align: left; /*center text for this column only. Use it?*/
}
.Warning {
color: #34568B;
background-color: #FFCA28;
text-align: left; /*center text for this column only. Use it?*/
}
.Error {
color: #F7F9F9;
background-color: #DE3163;
text-align: left; /*center text for this column only. Use it?*/
}
</style>
"@
<# CODE_SECTION_6
Get data.
#>
$CodeSection="6"
# Summary
$DbQuery="SELECT 'Management Group' AS Column1,
ManagementGroupName AS Column2
FROM [$Script:OpsDbName].[dbo].[__MOMManagementGroupInfo__]
UNION ALL
SELECT 'Active Alerts',
CAST(COUNT(*) AS NVARCHAR)
FROM [$Script:OpsDbName].[dbo].[AlertView]
WHERE ResolutionState='1'
and Severity!='0'
UNION ALL
SELECT 'Total Windows Agents',
CAST(COUNT(*) AS NVARCHAR)
FROM [$Script:OpsDbName].[dbo].[MT_Microsoft`$SystemCenter`$Agent]
UNION ALL
SELECT 'Total UNIX/Linux Agents',
CAST(COUNT(*) AS NVARCHAR)
FROM [$Script:OpsDbName].[dbo].[MT_Microsoft`$Unix`$Computer]
UNION ALL
SELECT 'Total Network Devices',
CAST(COUNT(*) AS NVARCHAR)
FROM [$Script:OpsDbName].[dbo].[MT_System`$NetworkManagement`$Node]
UNION ALL
SELECT 'Broken Windows Agents',
CAST(COUNT(*) AS NVARCHAR)
FROM [$Script:OpsDbName].[dbo].[ManagedEntityGenericView] as tb1 --table 1
INNER JOIN [$Script:OpsDbName].[dbo].[ManagedTypeView] as tb2 -- table 2
ON tb1.MonitoringClassId = tb2.Id
WHERE (tb2.Name = 'Microsoft.SystemCenter.Agent')
AND tb1.IsAvailable=0
AND (tb1.InMaintenanceMode=0 OR tb1.InMaintenanceMode IS NULL) --need InMaintenanceMode for this bit.
UNION ALL
SELECT 'Broken UNIX/Linux Agents',
CAST(COUNT(*) AS NVARCHAR)
FROM [$Script:OpsDbName].[dbo].[ManagedEntityGenericView] as tb1 --table 1
INNER JOIN ManagedTypeView as tb2 -- table 2
ON tb1.MonitoringClassId = tb2.Id
WHERE (tb2.Name='Microsoft.Unix.Computer')
AND tb1.IsAvailable=0
AND (InMaintenanceMode=0 OR InMaintenanceMode IS NULL) --need InMaintenanceMode for this bit.
UNION ALL
SELECT 'Pending Windows Agents',
CAST(COUNT(*) AS NVARCHAR)
FROM [$Script:OpsDbName].[dbo].[AgentPendingAction]
UNION ALL
SELECT 'Windows Servers in Maintenance Mode',
CAST(COUNT(*) AS NVARCHAR)
FROM [$Script:OpsDbName].[dbo].[MaintenanceModeView] tb1
INNER JOIN BaseManagedEntity tb2
ON tb1.BaseManagedEntityId=tb2.BaseManagedEntityId
WHERE IsInMaintenanceMode='1'
AND FullName like 'Microsoft.SystemCenter.HealthService:%'
AND IsDeleted='0'"
SQLQuery $Script:OpsDbServer $Script:OpsDbName $DbQuery
$Script:Summary=$Script:Datatable | ConvertTo-Html -Property Column1, Column2 -Fragment -PreContent "<h2>Summary</h2>"
$Script:Summary=$Script:Summary -replace '<tr><th>Column1</th><th>Column2</th></tr>',''
foreach ($i in $Script:Datatable) {
$Name=$i.column1
$Alert_Count=$i.column2
# Get active alerts. This table will only display if there are active alerts.
If ($Name -eq 'Active Alerts' -and $Alert_Count -gt 0) {
<#
The 'Category AS 'Age' column in the query below is a dummy placeholder because we get a "read only" error when we try to use a fake column in the query.
#>
$Now=Get-Date
$DbQuery="SELECT DISTINCT Id, TimeRaised AS 'Time Raised',
AlertStringName AS 'Alert Name',
MonitoringObjectDisplayName AS 'Object Name',
CustomField1 AS Category,
Owner AS 'Assigned To',
Category AS 'Age'
FROM [$OpsDbName].[dbo].[AlertView]
WHERE ResolutionState='1'
and Severity!='0'
ORDER BY TimeRaised desc"
SQLQuery $Script:OpsDbServer $Script:OpsDbName $Script:DbQuery
$ActiveAlerts=$Script:Datatable
$ActiveAlerts | foreach{
#UTC_Convert_1 $_."Time Raised"
[DateTime]$_."Time Raised"=$_."Time Raised".ToLocalTime() # Default alert time is in UTC, this converts to local time.
$Time_Diff=New-TimeSpan -Start $_."Time Raised" -End $Now
$Time_Diff_Days=$Time_Diff.days
$Time_Diff_Hours=$Time_Diff.hours
$Time_Diff_Mins=$Time_Diff.minutes
[string]$_."Age"="$Time_Diff_Days`d $Time_Diff_Hours`h $Time_Diff_Mins`m"
}
$ActiveAlerts=$Script:Datatable | ConvertTo-Html -Property 'Time Raised', 'Alert Name', 'Object Name', 'Category', 'Assigned To', 'Age' -Fragment -PreContent "<h2>Active Alerts</h2>"
$ActiveAlerts=$ActiveAlerts -replace '<td>Unknown','<td class="Warning">Unknown'
<#
17.12.2021 - Not using this.
$ActiveAlerts=$ActiveAlerts -replace '<td>Error','<td class="Error">'
$ActiveAlerts=$ActiveAlerts -replace '<td>Warning','<td class="Warning">'
#>
}
# Get Broken Windows Agents. This table will only display if there are active alerts.
If ($Name -eq 'Broken Windows Agents' -and $Alert_Count -gt 0) {
#write-host -foregroundcolor yellow "yes"
$DbQuery="SELECT UPPER (tb1.DisplayName) AS 'Server Name'
FROM [$OpsDbName].[dbo].[ManagedEntityGenericView] as tb1 --table 1
INNER JOIN [$OpsDbName].[dbo].[ManagedTypeView] as tb2 -- table 2
ON tb1.MonitoringClassId = tb2.Id
WHERE (tb2.Name = 'Microsoft.SystemCenter.Agent')
AND tb1.IsAvailable=0
AND (tb1.InMaintenanceMode=0 OR tb1.InMaintenanceMode IS NULL) --need InMaintenanceMode for this bit.
ORDER BY 'Server Name'"
SQLQuery $OpsDbServer $OpsDbName $DbQuery
$Grey_Win_Agents=$Datatable | ConvertTo-Html -Property 'Server Name' -Fragment -PreContent "<h2>Broken Windows Agents</h2>"
#$Grey_Win_Agents=$Grey_Win_Agents -replace '<tr><th>Server Name</th></tr>',''
}
# Get Broken UNIX/Linux Agents. This table will only display if there are active alerts.
If ($Name -eq 'Broken UNIX/Linux Agents' -and $Alert_Count -gt 0) {
#write-host -foregroundcolor yellow "yes"
$DbQuery="SELECT UPPER (tb1.DisplayName) AS 'Server Name'
FROM [$OpsDbName].[dbo].[ManagedEntityGenericView] as tb1 --table 1
INNER JOIN [$OpsDbName].[dbo].[ManagedTypeView] as tb2 -- table 2
ON tb1.MonitoringClassId = tb2.Id
WHERE (tb2.Name='Microsoft.Unix.Computer')
AND tb1.IsAvailable=0
AND (InMaintenanceMode=0 OR InMaintenanceMode IS NULL) --need InMaintenanceMode for this bit.
ORDER BY 'Server Name'"
SQLQuery $OpsDbServer $OpsDbName $DbQuery
$Grey_UNIX_Linux_Agents=$Datatable | ConvertTo-Html -Property 'Server Name' -Fragment -PreContent "<h2>Broken UNIX/Linux Agents</h2>"
#$Grey_UNIX_Linux_Agents=$Grey_UNIX_Linux_Agents -replace '<tr><th>Server Name</th></tr>',''
}
# Get Pending Windows Agents. This table will only display if there are active alerts.
If ($Name -eq 'Pending Windows Agents' -and $Alert_Count -gt 0) {
$DbQuery="SELECT AgentName AS 'Server Name', LastModified AS 'Time Raised'
FROM [$OpsDbName].[dbo].[AgentPendingAction]
ORDER BY AgentName"
SQLQuery $OpsDbServer $OpsDbName $DbQuery
$Pending_Windows_Agents=$Script:Datatable
$Pending_Windows_Agents | foreach{
#UTC_Convert_1 $_."Time Raised"
[DateTime]$_."Time Raised"=$_."Time Raised".ToLocalTime() # Default alert time is in UTC, this converts to local time.
}
$Pending_Windows_Agents=$Datatable | ConvertTo-Html -Property 'Server Name', 'Time Raised' -Fragment -PreContent "<h2>Pending Windows Agents</h2>"
}
# Get Windows MM. This table will only display if there are active alerts.
If ($Name -eq 'Windows Servers in Maintenance Mode' -and $Alert_Count -gt 0) {
$DbQuery="SELECT DisplayName AS 'Server Name', StartTime AS 'Start Time', ScheduledEndTime AS 'End Time', [User] AS 'Scheduled By',
CASE tb1.ReasonCode
WHEN '0' THEN 'Other (Planned)' 
WHEN '1' THEN 'Other (Unplanned)' 
WHEN '2' THEN 'Hardware: Maintenance (Planned)' 
WHEN '3' THEN 'Hardware: Maintenance (Unplanned)' 
WHEN '4' THEN 'Hardware: Installation (Planned)' 
WHEN '5' THEN 'Hardware: Installation (Unplanned)' 
WHEN '6' THEN 'Operating System: Reconfiguration (Planned)' 
WHEN '7' THEN 'Operating System: Reconfiguration (Unplanned)' 
WHEN '8' THEN 'Application: Maintenance (Planned)' 
WHEN '9' THEN 'Application: Maintenance (Unplanned)' 
WHEN '10' THEN 'Application: Installation (Planned)' 
WHEN '11' THEN 'Application: Unresponsive' 
WHEN '12' THEN 'Application:  Unstable' 
WHEN '13' THEN 'Security Issue' 
WHEN '14' THEN 'Loss of network connectivity (Unplanned)' 
END AS 'Category',
tb1.Comments as Reason
FROM [$OpsDbName].[dbo].[MaintenanceModeView] tb1
inner join BaseManagedEntity tb2
on tb1.BaseManagedEntityId=tb2.BaseManagedEntityId
where IsInMaintenanceMode='1'
and FullName like 'Microsoft.SystemCenter.HealthService:%'
and IsDeleted='0'
order by DisplayName"
SQLQuery $OpsDbServer $OpsDbName $DbQuery
$Windows_MM=$Script:Datatable
$Windows_MM | foreach{
[DateTime]$_."Start Time"=$_."Start Time".ToLocalTime() # Default alert time is in UTC, this converts to local time.
[DateTime]$_."End Time"=$_."End Time".ToLocalTime() # Default alert time is in UTC, this converts to local time.
}
$Windows_MM=$Datatable | ConvertTo-Html -Property 'Server Name', 'Start Time', 'End Time', 'Scheduled By', Category, Reason -Fragment -PreContent "<h2>Windows Servers in Maintenance Mode</h2>"
}
}
<# CODE_SECTION_10
Finish generating report.
#>
$CodeSection="10"
$Header="<h1>$Identifier - SCOM Daily Report</h1>"
$Report_Date="<p>This report was generated on $Start</p>"
$EmailBody=ConvertTo-HTML -Head $Head -Body "$Header $Report_Date $GenerationTime $Summary $ActiveAlerts $Grey_Win_Agents $Grey_UNIX_Linux_Agents $Pending_Windows_Agents $Windows_MM"
SendEmail $EmailFromAddress $EmailToAddress $EmailServer $EmailPort
LogAndQuit
}
Catch
{
TerminatingError
}
}
DailyReport -EmailFromAddress $EmailFromAddress -EmailToAddress $EmailToAddress -EmailServer $EmailServer -EmailPort $EmailPort -Identifier $Identifier
# End Daily Report
]]>
</ScriptBody>
<Parameters>
<Parameter>
<Name>EmailFromAddress</Name>
<Value>$Config/EmailFromAddress$</Value>
</Parameter>
<Parameter>
<Name>EmailToAddress</Name>
<Value>$Config/EmailToAddress$</Value>
</Parameter>
<Parameter>
<Name>EmailServer</Name>
<Value>$Config/EmailServer$</Value>
</Parameter>
<Parameter>
<Name>EmailPort</Name>
<Value>$Config/EmailPort$</Value>
</Parameter>
<Parameter>
<Name>Identifier</Name>
<Value>$Config/Identifier$</Value>
</Parameter>
</Parameters>
<TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
</WriteAction>
</MemberModules>
<Composition>
<Node ID="WA" />
</Composition>
</Composite>
</ModuleImplementation>
<OutputType>System!System.BaseData</OutputType>
<InputType>System!System.BaseData</InputType>
</WriteActionModuleType>
<!--**************************************** ALERT MANAGEMENT WRITE ACTION MODULE ****************************************-->
<WriteActionModuleType ID="SCOM.WAM.URAlertManagement" Accessibility="Internal" Batching="false">
<Configuration>
<!--<xsd:element minOccurs="1" name="ComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element minOccurs="1" name="MpBackupFolder" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" /> 
-->
<xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
</Configuration>
<OverrideableParameters>
<OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
</OverrideableParameters>
<ModuleImplementation Isolation="Any">
<Composite>
<MemberModules>
<WriteAction ID="WA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
<ScriptName>SCOM.AlertManagement.ps1</ScriptName>
<ScriptBody><![CDATA[
# Start Alert MANAGEMENT
<#**************************************** FUNCTION: LogAndQuit ****************************************#>
Function LogAndQuit {
If ($Script:CountError -gt 0) {
# Codes: 0=Information, 1=Error, 2=Warning
$EventId=17618 # error
$EventLevel=2
} Else {
$Script:CountError=0 # If no errors set this value so it appears in the event.
$EventId=17617 # success
$EventLevel=0
}
# Use MOMScriptAPI.LogScriptEvent method to log events because Write-EventLog doesn't work on new OSs.
$ObjMomApi.LogScriptEvent("SCOM.AlertManagement.ps1", $EventId, $EventLevel, "Alert Management script executed.`nWorkflow Name: SCOM.Rule.AlertManagement`nManagement Pack: SCOM.UpdateRollup (2023.3.21.0)`nPowerShell Version: $PSVersion`nAlerts: $CountAlerts`nIssues Detected: $Script:CountError`n$Script:Message") # $Error dumps errors into the event.
}
<#**************************************** FUNCTION: TerminatingError ****************************************#>
Function TerminatingError
{
$script:CountError+=1
$script:Message+="[CODE_SECTION_$CodeSection] A terminating error occurred. Error output: (" + $_.Exception.Message + ").`n"
LogAndQuit
}
<#**************************************** FUNCTION: AlertManagement ****************************************#>
Function AlertManagement {
$ErrorActionPreference="SilentlyContinue"
Try {
<# FOR TESTING
cls
$csv=""
$csv+="AlertName^CATEGORY^MpName^ObjectName^OWNER`r"
#>
<# CODE_SECTION_1
Load required objects.
#>
$CodeSection="1"
$ObjMomApi=New-Object -comObject 'MOM.ScriptAPI' # MOMScriptAPI object.
<# CODE_SECTION_2.
Get powershell version.
This is shown in events to assist troubleshooting if powershell doesn't play nice.
#>
$CodeSection="2"
$PSVersion=$PSVersionTable.PSVersion
[string]$PSMajor=$PSVersion.Major
[string]$PSMinor=$PSVersion.Minor
$PSVersion=$PSMajor + "." + $PSMinor
<# CODE_SECTION_3
Set common variables.
#>
$CodeSection="3"
$CompanyNameServerTeam="CompanyName Server Team"
$CompanyNameMonitoringTeam="CompanyName Monitoring Team"
$CompanyNameSccmTeam="CompanyName SCCM Team"
$CompanyNameSharePointTeam="CompanyName SharePoint Team"
$CompanyNameCitrixTeam="CompanyName Citrix Team"
$CompanyNameEndpointSecurityTeam="CompanyName Endpoint Security Team"
$CompanyNameBackupStorageTeam="CompanyName Backup and Storage Team"
$CompanyNameADManagement="CompanyName AD Management"
$Unknown="Unknown"
<# CODE_SECTION_4
Load SCOM module.
#>
$CodeSection="4"
$PowerShellInstallDirectory=(Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\System Center Operations Manager\12\Setup\Powershell\V2").InstallDirectory
Import-module $PowerShellInstallDirectory`OperationsManager
New-DefaultManagementGroupConnection
$MgName=(Get-SCOMManagementGroupConnection).ManagementGroupName
$MgServer=(Get-SCOMManagementGroupConnection).ManagementServerName
$Script:SCOMMGName=(Get-SCOMManagementGroup).Name
<# CODE_SECTION_5
Process alerts.
#>
$Alerts=Get-SCOMAlert -Criteria "ResolutionState=0" # just get new alerts for now.
$CountAlerts=$Alerts.count
If ($CountAlerts -gt 0) {
foreach($Alert in $Alerts) {
# reset variables
$category="" # need this?
$owner="" # need this?
if($Alert.ismonitoralert) {
$Workflow=get-scommonitor -id $Alert.MonitoringRuleId
} else {
$Workflow=get-scomrule -id $Alert.MonitoringRuleId
}
$AlertName=$Alert.name
$ObjectName=$Alert.MonitoringObjectDisplayName # use this as starting point, it will need to be changed per alert if necessary.
$WorkflowName=$Workflow.name
$MpName=$Workflow.GetManagementPack().name
# This assigns alerts based on the mgmt pack it came from.
switch -wildcard ($MpName) {
# Active Directory
"Microsoft.Windows.Server.AD.*" {$category="Active Directory"; $owner=$CompanyNameADManagement; BREAK}
"ActiveDirectory.Monitoring" {$category="Active Directory"; $owner=$CompanyNameADManagement; BREAK}
# ADFS
"Microsoft.ActiveDirectoryFederationServices.2012.R2" {$category="ADFS"; $owner=$CompanyNameServerTeam; BREAK}
# Citrix
"CitrixA.Monitoring" {$category="Citrix"; $owner=$CompanyNameCitrixTeam; BREAK}
# Cmdb
"SCOM.Cmdb" {$category="Cmdb"; $owner=$CompanyNameMonitoringTeam; BREAK}
# Commvault
"Commvault.Monitoring" {$category="Commvault"; $owner=$CompanyNameBackupStorageTeam; BREAK}
# DHCP
"Microsoft.Windows.DHCPServer.*" {$category="DHCP"; $owner=$CompanyNameServerTeam; BREAK}
# DNS
"*.DNS*" {$category="DNS"; $owner=$CompanyNameServerTeam; BREAK}
# Exchange
"*Exchange.*" {$category="Exchange"; $owner=$CompanyNameServerTeam; BREAK}
# IIS
"Microsoft.Windows.InternetInformationServices.*" {$category="IIS"; $owner=$CompanyNameServerTeam; BREAK}
# McAfee
"McAfee.Monitoring" {$category="McAfee"; $owner=$CompanyNameEndpointSecurityTeam; BREAK}
# Network
"System.NetworkManagement.Monitoring" {$category="Network"; $owner=$Unknown; BREAK}
# SCOM
"Microsoft.SystemCenter.*" {$category="SCOM"; $owner=$CompanyNameMonitoringTeam; BREAK}
"SCOM.UpdateRollup" {$category="SCOM"; $owner=$CompanyNameMonitoringTeam; BREAK}
# SCCM
"Microsoft.SystemCenter2012.ConfigurationManager.*" {$category="SCCM"; $owner=$CompanyNameSccmTeam; BREAK}
# SharePoint
"Microsoft.SharePoint.*" {$category="SharePoint"; $owner=$CompanyNameSharePointTeam; BREAK}
# SQL
"Microsoft.SQLServer.*" {$category="SQL"; $owner=$CompanyNameServerTeam; BREAK}
# UNIX / Linux
"Microsoft.Linux.*" {$category="Linux Server"; $owner=$CompanyNameServerTeam; BREAK}
"Microsoft.Unix.*" {$category="UNIX Server"; $owner=$CompanyNameServerTeam; BREAK}
# VMware Carbon Black
"VMware.CarbonBlack.Monitoring" {$category="Carbon Black"; $owner=$CompanyNameServerTeam; BREAK}
# VMware Workspace One
"VMware.WorkspaceOne.Monitoring" {$category="VMware Workspace ONE"; $owner=$CompanyNameServerTeam; BREAK}
# Windows certificates
"Certificate.Monitoring" {$category="Certificate"; $owner=$CompanyNameServerTeam; BREAK}
# Windows clusters
"*.Cluster.*" {$category="Windows Cluster"; $owner=$CompanyNameServerTeam; BREAK}
"Microsoft.Windows.Server.ClusterSharedVolumeMonitoring" {$category="Windows Cluster"; $owner=$CompanyNameServerTeam; BREAK}
# Windows server
"Microsoft.Windows.Server.*" {$category="Windows Server"; $owner=$CompanyNameServerTeam; BREAK}
# Client
"*Client*" {$category="Client"; $owner=$CompanyNameMonitoringTeam; BREAK}
default {
$Script:CountError+=1
$Script:Message+="[CODE_SECTION_$CodeSection] MP missing in switch statement for alert '$Alert'`n"
$category="Unknown"; $owner=$CompanyNameMonitoringTeam
}
} # end switch
# This assigns alerts based on the monitor/rule name. Put workflow dot name in switch statement.
switch -wildcard ($WorkflowName) {
<#
25/3/2022 - Monitoring team now manage agent health.
"Microsoft.SystemCenter.HealthService.Heartbeat" {$owner=$CompanyNameServerTeam; $category="Windows Server"; BREAK} 
#>
"Microsoft.SystemCenter.HealthService.ComputerDown" {$owner=$CompanyNameServerTeam; $category="Windows Server"; BREAK} 
"Microsoft.Windows.Server.*.LogicalDisk.FreeSpace" {$ObjectName=$Alert.MonitoringObjectPath; BREAK} 
"Microsoft.Unix.LogFileModuleErrors.Alert" {$owner=$CompanyNameMonitoringTeam; $category="SCOM"; BREAK} 
"ActiveDirectory.Monitor.TimeDriftScriptError" {$owner=$CompanyNameMonitoringTeam; $category="SCOM"; BREAK}
# This is so we can see ADFS certificate alerts in the Certificates > Active Alerts view.
"Microsoft.ActiveDirectoryFederationServices2012R2.FederationServerTrustsHaveExpiredCertsWarningMonitor" {$category="Certificate"; BREAK}
}
# This assigns alerts based on the alert name.
switch ($AlertName) {
"Web Application Unavailable: Hitachi Management portal" {$owner=$CompanyNameBackupStorageTeam; $category="Hitachi"; BREAK} 
"Web Application Unavailable: NetApp Management portal" {$owner=$CompanyNameBackupStorageTeam; $category="NetApp"; BREAK} 
}
# Update alert properties and move to next.
Set-SCOMAlert -Alert $Alert -Owner $owner -CustomField1 $Category -CustomField2 $ObjectName -ResolutionState 1
} # end for loop
#}
} # end if count -ne 0
LogAndQuit
} # and try
Catch
{
TerminatingError
}
} # end function
AlertManagement
# End AlertManagement
]]>
</ScriptBody>
<!--
<Parameters>
<Parameter>
<Name>ComputerName</Name>
<Value>$Config/ComputerName$</Value>
</Parameter>
<Parameter>
<Name>MpBackupFolder</Name>
<Value>$Config/MpBackupFolder$</Value>
</Parameter>			  
</Parameters>
-->
<TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
</WriteAction>
</MemberModules>
<Composition>
<Node ID="WA" />
</Composition>
</Composite>
</ModuleImplementation>
<OutputType>System!System.BaseData</OutputType>
<InputType>System!System.BaseData</InputType>
</WriteActionModuleType>
<!--**************************************** MP BACKUP WRITE ACTION MODULE ****************************************-->
<WriteActionModuleType ID="SCOM.WAM.URMpBackup" Accessibility="Internal" Batching="false">
<Configuration>
<xsd:element minOccurs="1" name="ComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element minOccurs="1" name="MpBackupFolder" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
</Configuration>
<OverrideableParameters>
<OverrideableParameter ID="MpBackupFolder" Selector="$Config/MpBackupFolder$" ParameterType="string" />
<OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
</OverrideableParameters>
<ModuleImplementation Isolation="Any">
<Composite>
<MemberModules>
<WriteAction ID="WA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
<ScriptName>SCOM.MpBackup.ps1</ScriptName>
<ScriptBody><![CDATA[
# Start MP Backup
Param ($MpBackupFolder)
<#**************************************** FUNCTION: LogAndQuit ****************************************#>
Function LogAndQuit {
If ($Script:CountError -gt 0) {
$EventId=17613
$EventLevel=2
} Else {
$Script:CountError=0 # If no errors set this value so it appears in the event.
$EventId=17612
$EventLevel=0
}
# Use MOMScriptAPI.LogScriptEvent method to log events because Write-EventLog doesn't work on new OSs.
$ObjMomApi.LogScriptEvent("SCOM.MpBackup.ps1", $EventId, $EventLevel, "Management pack backup script executed.`nWorkflow Name: SCOM.Rule.MpBackup`nManagement Pack: SCOM.UpdateRollup (2023.3.21.0)`nPowerShell Version: $PSVersion`nIssues Detected: $Script:CountError`n$Script:Message") # $Error dumps errors into the event.
}
<#**************************************** FUNCTION: CheckNull ****************************************#>
Function CheckNull ($PassedInParam) {
If ([string]::IsNullOrEmpty($PassedInParam)) {
$Script:IsItNull=$True # Update this so we can make decisions.
$Script:CountError+=1
$Script:Message+="[CODE_SECTION_$CodeSection] $ValueToCheck is empty. Error output: ($Error).`n"
} Else {
$Script:IsItNull=$False # Update this so we can make decisions.
}}
<#**************************************** FUNCTION: TerminatingError ****************************************#>
Function TerminatingError
{
$script:CountError+=1
$script:Message+="[CODE_SECTION_$CodeSection] A terminating error occurred. Error output: (" + $_.Exception.Message + ").`n"
LogAndQuit
}
<#**************************************** FUNCTION: MpBackup ****************************************#>
Function MpBackup {
$ErrorActionPreference="Stop"
Try {
<# FOR TESTING
$MpBackupFolder="C:\temp\mpbackups"
#>
<# CODE_SECTION_1
Load required objects.
#>
$CodeSection="1"
$ObjMomApi=New-Object -comObject 'MOM.ScriptAPI' # MOMScriptAPI object.
<# CODE_SECTION_2.
Get powershell version.
This is shown in events to assist troubleshooting if powershell doesn't play nice.
#>
$CodeSection="2"
$PSVersion=$PSVersionTable.PSVersion
[string]$PSMajor=$PSVersion.Major
[string]$PSMinor=$PSVersion.Minor
$PSVersion=$PSMajor + "." + $PSMinor
<# CODE_SECTION_3
Set common variables.
#>
$CodeSection="3"
$ComputerFqdn=([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname
$ValueToCheck="ComputerFqdn"; CheckNull $ComputerFqdn # Expect value.
<# CODE_SECTION_4
Check output folder and load SCOM module.
#>
$CodeSection="4"
If (-Not(Test-Path -Path $MpBackupFolder)) {
$Script:CountError+=1
$Script:Message+="[CODE_SECTION_$CodeSection] The mp backup folder $MpBackupFolder does not exist.`n"
} Else {
$PowerShellInstallDirectory=(Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\System Center Operations Manager\12\Setup\Powershell\V2").InstallDirectory
$ValueToCheck="PowerShellInstallDirectory"; CheckNull $PowerShellInstallDirectory # Expect value.
If ($Script:IsItNull -ne $True) { # 
Import-module $PowerShellInstallDirectory`OperationsManager
New-DefaultManagementGroupConnection
$Script:SCOMMGName=(Get-SCOMManagementGroup).Name
$MPs=Get-SCOMManagementPack | Where-Object {$_.Sealed -eq $False}
$MPs | ForEach-Object {
Export-SCOMManagementPack -ManagementPack:$_ -Path:$MpBackupFolder
}}}
LogAndQuit
}
Catch
{
TerminatingError
}
}
MpBackup -MpBackupFolder $MpBackupFolder # Need this to pass params in properly.
# End MP Backup
]]>
</ScriptBody>
<Parameters>
<Parameter>
<Name>ComputerName</Name>
<Value>$Config/ComputerName$</Value>
</Parameter>
<Parameter>
<Name>MpBackupFolder</Name>
<Value>$Config/MpBackupFolder$</Value>
</Parameter>			  
</Parameters>
<TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
</WriteAction>
</MemberModules>
<Composition>
<Node ID="WA" />
</Composition>
</Composite>
</ModuleImplementation>
<OutputType>System!System.BaseData</OutputType>
<InputType>System!System.BaseData</InputType>
</WriteActionModuleType>
<!--**************************************** MG REPORT WRITE ACTION MODULE ****************************************-->
<WriteActionModuleType ID="SCOM.WAM.URMgReport" Accessibility="Internal" Batching="false">
<Configuration>
<xsd:element minOccurs="1" name="ComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element minOccurs="1" name="MgReportFolder" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
<xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
</Configuration>
<OverrideableParameters>
<OverrideableParameter ID="MgReportFolder" Selector="$Config/MgReportFolder$" ParameterType="string" />
<OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
</OverrideableParameters>
<ModuleImplementation Isolation="Any">
<Composite>
<MemberModules>
<WriteAction ID="WA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
<ScriptName>SCOM.MgReport.ps1</ScriptName>
<ScriptBody><![CDATA[
<#
notes as neede
#>
# Start MG Report
Param ($MgReportFolder)
<#**************************************** FUNCTION: LogAndQuit ****************************************#>
Function LogAndQuit {
If ($Script:CountError -gt 0) {
$EventId=17615
$EventLevel=2
} Else {
$Script:CountError=0 # If no errors set this value so it appears in the event.
$EventId=17614
$EventLevel=0
}
# Use MOMScriptAPI.LogScriptEvent method to log events because Write-EventLog doesn't work on new OSs.
$ObjMomApi.LogScriptEvent("SCOM.MgReport.ps1", $EventId, $EventLevel, "Management group report script executed.`nWorkflow Name: SCOM.Rule.MgReport`nManagement Pack: SCOM.UpdateRollup (2023.3.21.0)`nPowerShell Version: $PSVersion`nIssues Detected: $Script:CountError`n$Script:Message") # $Error dumps errors into the event.
}
<#**************************************** FUNCTION: CheckNull ****************************************#>
Function CheckNull ($PassedInParam) {
If ([string]::IsNullOrEmpty($PassedInParam)) {
$Script:IsItNull=$True # Update this so we can make decisions.
$Script:CountError+=1
$Script:Message+="[CODE_SECTION_$CodeSection] $ValueToCheck is empty. Error output: ($Error).`n"
} Else {
$Script:IsItNull=$False # Update this so we can make decisions.
}}
<#**************************************** FUNCTION: TerminatingError ****************************************#>
Function TerminatingError
{
$script:CountError+=1
$script:Message+="[CODE_SECTION_$CodeSection] A terminating error occurred. Error output: (" + $_.Exception.Message + ").`n"
LogAndQuit
}
<#**************************************** FUNCTION: SQLQuery ****************************************#>
Function SQLQuery ($Script:DbServer,$Script:DbName,$Script:DbQuery) {
$Connection=New-Object System.Data.SQLClient.SQLConnection
$Connection.ConnectionString="Data Source=$DbServer;Database=$DbName;Trusted_Connection=True;"
$Connection.Open()
$Command=New-Object System.Data.SQLClient.SQLCommand
$Command.Connection=$Connection
$Command.CommandText=$DbQuery
$Reader=$Command.ExecuteReader()
$Script:Datatable=New-Object System.Data.DataTable
$Script:Datatable.Load($Reader)
$Connection.Close() 
}
<#**************************************** FUNCTION: MgReport ****************************************#>
Function MgReport {
$ErrorActionPreference="Stop"
Try {
<# FOR TESTING
$Error.Clear()
$MgReportFolder="C:\temp"
#>
<# CODE_SECTION_1
Load things we'll need.
#>
$CodeSection="1"
$Start=(Get-Date -format f) # use this to calculate report generation duration.
$User=[System.Security.Principal.WindowsIdentity]::GetCurrent().Name
$ObjMomApi=New-Object -comObject 'MOM.ScriptAPI' # MOMScriptAPI object.
$SetupRegKey="HKLM:\SOFTWARE\Microsoft\Microsoft Operations Manager\3.0\Setup" # don't do null check on these 4 reg values, the script is running so all good.
$Script:OpsDbName=(Get-ItemProperty $SetupRegKey).DatabaseName
$Script:OpsDbServer=(Get-ItemProperty $SetupRegKey).DatabaseServerName
$Script:DWDbName=(Get-ItemProperty $SetupRegKey).DataWarehouseDBName
$Script:DwDbServer=(Get-ItemProperty $SetupRegKey).DataWarehouseDBServerName
<# CODE_SECTION_2.
Get powershell version.
This is shown in events to assist troubleshooting if powershell doesn't play nice.
#>
$CodeSection="2"
$PSVersion=$PSVersionTable.PSVersion
[string]$PSMajor=$PSVersion.Major
[string]$PSMinor=$PSVersion.Minor
$PSVersion=$PSMajor + "." + $PSMinor
<# CODE_SECTION_3
Set common variables.
#>
$CodeSection="3"
$ComputerFqdn=([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname
$ValueToCheck="ComputerFqdn"; CheckNull $ComputerFqdn # Expect value.
<# CODE_SECTION_4
Check output folder and load SCOM module.
#>
$CodeSection="4"
If (-Not(Test-Path -Path $MgReportFolder)) {
$Script:CountError+=1
$Script:Message+="[CODE_SECTION_$CodeSection] The report folder $MgReportFolder does not exist.`n"
} Else {
$PowerShellInstallDirectory=(Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\System Center Operations Manager\12\Setup\Powershell\V2").InstallDirectory
$ValueToCheck="PowerShellInstallDirectory"; CheckNull $PowerShellInstallDirectory # Expect value.
If ($Script:IsItNull -ne $True) {
Import-module $PowerShellInstallDirectory`OperationsManager
New-DefaultManagementGroupConnection
$MgName=(Get-SCOMManagementGroup).Name
$ValueToCheck="MgName"; CheckNull $MgName # Expect value.
<# may use later.
$MPs=Get-SCOMManagementPack | Where-Object {$_.Sealed -eq $False}
$MPs | ForEach-Object {
Export-SCOMManagementPack -ManagementPack:$_ -Path:$MgReportFolder
}
#>
}
<# CODE_SECTION_5
Build html/css for report.
#>
$CodeSection="5"
$Head=@"
<style>
h1 {
font-size: 30px;
color: #555555;
}
h2 {
font-size: 20px;
color: #424949;
}
h3 {
font-size: 15px;
color: #555555;
}
h4 {
font-size: 12px;
color: #555555;
}
h1, h2, h3, h4 { /*common settings for h1, h2*/
font-family: Arial;
text-align: left;
}
th {
text-align: center;
font-size: 12px; /*header font size.*/
background-color: gray;
color: white; /*font colour*/
padding: 5px 5px; /*padding */
font-weight: normal; /*remove bold heading*/
}
td {
font-size: 11px; /*row font size.*/
color: #555555;
text-align: left;
padding: 2px 4px; /*This adds more space between columns. 1st digit=row height, 2nd digit=row width.*/
}
table {
white-space:nowrap;
border-collapse: collapse;
border: 1px solid #F2F2F2;
/*width: 100%; /*each table will use x% screen width. Not using.*/
}
th, td { /*common settings for table header and table data.*/
font-family: Arial;
border: 1px solid #F2F2F2;
}
tr:nth-child(even) {background-color: #F2F2F2;}
p {
font-family: Arial;
font-size: 11px;
color: #555555
}
#CreationDate {
font-family: Arial;
color: orange;
font-size: 12px;
}
.Info {
color: #F7F9F9;
background-color: #4CAF50;
text-align: left; /*center text for this column only. Use it?*/
}
.Warning {
color: #555555;
background-color: yellow;
text-align: left; /*center text for this column only. Use it?*/
}
.Error {
color: #F7F9F9;
background-color: #E74C3C;
text-align: left; /*center text for this column only. Use it?*/
}
.btn-group button {
background-color: gray;
font-size: 12px; /*row font size.*/
border: 1px solid gray;
color: white; /* White text */
/*padding: 10px 24px; /* Some padding */
padding: 5px 5px; /* Some padding */
cursor: pointer; /* Pointer/hand icon */
border-radius: 4px;
width:150px; /*remove to auto-size width*/
}
/* Add a background color on hover */
.btn-group button:hover {
background-color: #555555;
}
/*Change to this colour hovering over the index button.*/
a:hover {
color: #555555;
}
.indexbutton{
font-family: Arial;
position:fixed;
/*width:50px;
height:50px;*/
bottom:20px;
right:20px;
background-color:#4CAF50;
color: white;
border-radius:4px;
text-align:center;
box-shadow: 2px 2px 3px #999;
padding: 10px;
text-decoration: none; /*this removes hyperlinks over the text*/
}
</style>
"@
$H2Index="<h2><a id=Index>Index</a></h2>"
$H1SCOMReport="<h1>SCOM Management Group Report</h1>"
$IndexButton="<a href='#Index' class='indexbutton'>Index</a>"
$IndexButtonGroup="<div class='btn-group'; margin-left:100px;>
<a href='#Databases'><button>Databases</button></a>
<a href='#UpdateRollups'><button>Update Rollups</button></a>
</div>"
<# CODE_SECTION_6
Mgmt group summary.
#>
$CodeSection="6"
$DbQuery="SELECT 'SCOM Version' AS Column1,
CASE 
WHEN MgmtServerVersion_E8B08CCC_887D_3193_5AF3_01E1225E8799 like '%2012 R2%' then 'Extended support - 2012 R2'
WHEN MgmtServerVersion_E8B08CCC_887D_3193_5AF3_01E1225E8799 like '%2016%' then '2016'
WHEN MgmtServerVersion_E8B08CCC_887D_3193_5AF3_01E1225E8799 like '%180%' then '1801'
WHEN MgmtServerVersion_E8B08CCC_887D_3193_5AF3_01E1225E8799 like '%2019%' then '2019'
ELSE 'Unknown - ' + MgmtServerVersion_E8B08CCC_887D_3193_5AF3_01E1225E8799
END AS Column2
FROM [$Script:OpsDbName].[dbo].[MTV_SCOM`$WindowsComputer]
WHERE RMS_771D4202_8806_363E_07CD_678590489569='yes'
UNION ALL
SELECT 'Active Alerts', CAST(CAST(COUNT(*) AS NVARCHAR) AS NVARCHAR)
FROM [$Script:OpsDbName].[dbo].[AlertView]
WHERE ResolutionState != '255'
UNION ALL /* I think this keeps them in current order. */
SELECT 'Windows Agents', CAST(CAST(COUNT(*) AS NVARCHAR) AS NVARCHAR)
FROM [$Script:OpsDbName].[dbo].[MT_HealthService]
WHERE IsAgent='1'
UNION ALL
SELECT 'Unix/Linux Agents', CAST(COUNT(*) AS NVARCHAR)
FROM [$Script:OpsDbName].[dbo].[MTV_Microsoft`$Unix`$Computer]
UNION ALL
SELECT 'Management Servers', CAST(COUNT(*) AS NVARCHAR)
FROM [$Script:OpsDbName].dbo.MT_Microsoft`$SystemCenter`$CollectionManagementServer
UNION ALL
SELECT 'Gateway Servers', CAST(COUNT(*) AS NVARCHAR)
FROM [$Script:OpsDbName].[dbo].[MT_Microsoft`$SystemCenter`$GatewayManagementServer]
UNION ALL
SELECT 'ACS Collectors', CAST(COUNT(*) AS NVARCHAR)
FROM [$Script:OpsDbName].[dbo].[MT_Microsoft`$SystemCenter`$ACS`$Collector]
UNION ALL
SELECT 'Network Devices', CAST(COUNT(*) AS NVARCHAR)
FROM [$Script:OpsDbName].[dbo].[MT_System`$NetworkManagement`$Node]
UNION ALL
SELECT 'Broken Health Service',
CASE
WHEN CAST(COUNT(*) AS NVARCHAR) >=1 then 'bad' + CAST(COUNT(*) AS NVARCHAR)
ELSE CAST(COUNT(*) AS NVARCHAR)
END
FROM [$Script:OpsDbName].[dbo].[ManagedEntityGenericView]
WHERE (FullName LIKE '%Microsoft.Unix.Computer:%' AND MonitoringClassId='360E5A02-BC9E-0000-2614-1972E304088A' -- class of the heartbeat alert for unux/linux.
OR FullName LIKE '%Microsoft.SystemCenter.HealthService:%' AND MonitoringClassId='AB4C891F-3359-3FB6-0704-075FBFE36710') -- class of the heartbeat alert for windows.
AND IsAvailable='0'
AND IsDeleted='0'
UNION ALL
SELECT 'Certificates', CAST(COUNT(*) AS NVARCHAR)
FROM [$Script:OpsDbName].[dbo].[MTV_SCOM`$WindowsComputer]
WHERE CertificateExpiry_C6B7EE9B_F90E_4559_9BBD_57C3C54411BF !='n/a'
UNION ALL
SELECT DISTINCT 'Maintenance Mode Jobs', CAST(COUNT(*) AS NVARCHAR)
FROM [$Script:OpsDbName].[dbo].[MaintenanceModeView]
WHERE IsInMaintenanceMode='1'"
SQLQuery $Script:OpsDbServer $Script:OpsDbName $DbQuery
$Summary=$Script:Datatable | ConvertTo-Html -Property Column1, Column2 -Fragment -PreContent "<h2>Summary</h2>"
$Summary=$Summary -replace '<tr><th>Column1</th><th>Column2</th></tr>',''
$Summary=$Summary -replace '<td>Extended support - 2012 R2','<td class="Warning">Extended support - 2012 R2'
$Summary=$Summary -replace '<td>bad','<td class="Warning">'
<# CODE_SECTION_7
OpsDb database summary.
#>
$CodeSection="7"
$DbQuery="SELECT 'Database Name' as Column1, sd.name as Column2 
FROM sys.databases sd where name='$Script:OpsDbName'
UNION ALL
SELECT 'Collation', collation_name FROM sys.databases where name='$Script:OpsDbName'
UNION ALL
SELECT 'Broker enabled',
CASE
WHEN CAST(is_broker_enabled as varchar(10)) = 0 THEN 'ConfigIssue - Disabled' --had to do weird CAST because it's a 'bit' data type.
WHEN CAST(is_broker_enabled as varchar(10)) = 1 THEN 'Yes'
END FROM sys.databases where name='$Script:OpsDbName'
UNION ALL
SELECT 'Full-text enabled',
CASE
WHEN is_fulltext_enabled=0 THEN 'ConfigIssue - Disabled'
WHEN is_fulltext_enabled=1 THEN 'Yes'
END FROM sys.databases where name='$Script:OpsDbName'
UNION ALL
/* removing this, it's too tricky querying 2 sql servers.
SELECT DISTINCT 'Database Server', [OpsDbServer_C2985C1B_CDAC_AAAE_B887_A7BB58E537BB] --use distinct in CASE there's 2+ mgmt servers.
FROM [$Script:OpsDbName].[dbo].[MT_SCOM`$WindowsComputer]
WHERE OpsDbServer_C2985C1B_CDAC_AAAE_B887_A7BB58E537BB != 'n/a' --need this else we'll return agents too.
UNION ALL
*/
SELECT 'Clustered',
CASE 
WHEN SERVERPROPERTY('IsClustered') = 0 THEN 'No' 
WHEN SERVERPROPERTY('IsClustered') = 1 THEN 'Yes'
END 
UNION ALL
SELECT 'Last full backup',
CASE
WHEN CAST(max(backup_finish_date)as varchar(50)) is null then 'No backup'
WHEN CAST(max(backup_finish_date)as varchar(50)) < dateadd(day, -7, getdate()) then 'Over 7 days - ' + CAST(max(backup_finish_date)as varchar(50))
ELSE CAST(max(backup_finish_date)as varchar(50))
END
FROM msdb.dbo.backupset
where database_name='$Script:OpsDbName'
AND type='D'"
SQLQuery $Script:OpsDbServer $Script:OpsDbName $DbQuery
$OpsDb=$Script:Datatable | ConvertTo-Html -Property Column1, Column2 -Fragment -PreContent "<h2><a id=Databases>Databases</a></h2><h3>Operational Database \ Summary</h3>"
$OpsDb=$OpsDb -replace '<tr><th>Column1</th><th>Column2</th></tr>',''
$OpsDb=$OpsDb -replace '<td>No backup','<td class="Error">No backup'
$OpsDb=$OpsDb -replace '<td>Over 7 days - ','<td class="Warning">Over 7 days - '
$OpsDb=$OpsDb -replace '<td>ConfigIssue - Disabled','<td class="Error">Disabled'
<# CODE_SECTION_8
OpsDb database file info.
#>
$CodeSection="8"
$DbQuery="USE $Script:OpsDbName
SELECT 
CASE 
WHEN alias_smf.type=0 THEN 'Database'
ELSE 'Log'
END AS 'File Type',
FORMAT(alias_sysfiles.size/128,'N0') + ' MB' as 'File Size',
FORMAT((FILEPROPERTY(alias_sysfiles.name,'SpaceUsed')/128),'N0') + ' MB' AS 'Used Space', 
FORMAT((alias_sysfiles.size/128)-(FILEPROPERTY(alias_sysfiles.name,'SpaceUsed')/128),'N0') + ' MB' AS 'Free Space', 
CASE 
WHEN alias_smf.growth=0 THEN 'Disabled'
ELSE 'Enabled'
END AS 'Autogrow',
alias_smf.physical_name AS 'Filename',
alias_smf.name AS 'Logical Name'
FROM dbo.sysfiles alias_sysfiles
INNER JOIN sys.master_files alias_smf ON alias_sysfiles.filename=alias_smf.physical_name
ORDER BY file_id"
SQLQuery $Script:OpsDbServer $Script:OpsDbName $DbQuery
$OpsDbFiles=$Script:Datatable | ConvertTo-Html -Property "File Type", "File Size", "Used Space", "Free Space", "Autogrow", "Filename", "Logical Name" -Fragment -PreContent "<h3>Operational Database \ Db Files</h3>"
$OpsDbFiles=$OpsDbFiles -replace '<td>Disabled','<td class="Error">Disabled'
<# CODE_SECTION_9
DWDb database summary.
#>
$CodeSection="9"
$DbQuery="SELECT 'Database Name' as Column1, sd.name as Column2
FROM sys.databases sd where name='$Script:DWDbName'
UNION ALL
SELECT 'Collation', collation_name FROM sys.databases where name='$Script:DWDbName'
UNION ALL
SELECT 'Broker enabled',
CASE
WHEN CAST(is_broker_enabled as varchar(10)) = 0 THEN 'ConfigIssue - Disabled' --had to do weird CAST because it's a 'bit' data type.
WHEN CAST(is_broker_enabled as varchar(10)) = 1 THEN 'Yes'
END FROM sys.databases where name='$Script:DWDbName'
UNION ALL
SELECT 'Full-text enabled',
CASE
WHEN is_fulltext_enabled=0 THEN 'ConfigIssue - Disabled'
WHEN is_fulltext_enabled=1 THEN 'Yes'
END FROM sys.databases where name='$Script:DWDbName'
UNION ALL
/* removing this, it's too tricky querying 2 sql servers.
SELECT DISTINCT 'Database Server', [OpsDbServer_C2985C1B_CDAC_AAAE_B887_A7BB58E537BB] --use distinct in case there's 2+ mgmt servers.
FROM [$Script:OpsDbName].[dbo].[MT_SCOM`$WindowsComputer]
WHERE OpsDbServer_C2985C1B_CDAC_AAAE_B887_A7BB58E537BB != 'n/a' --need this else we'll return agents too.
UNION ALL
*/
SELECT 'Clustered',
CASE 
WHEN SERVERPROPERTY('IsClustered') = 0 THEN 'No' 
WHEN SERVERPROPERTY('IsClustered') = 1 THEN 'Yes'
END 
UNION ALL
SELECT 'Last full backup',
case
when CAST(max(backup_finish_date)as varchar(50)) is null then 'No backup'
when CAST(max(backup_finish_date)as varchar(50)) < dateadd(day, -7, getdate()) then 'Over 7 days - ' + CAST(max(backup_finish_date)as varchar(50))
ELSE CAST(max(backup_finish_date)as varchar(50))
END
FROM msdb.dbo.backupset
where database_name='$Script:DWDbName'
and type='D'" # wrong need to remove this.
SQLQuery $Script:DwDbServer $Script:DWDbName $DbQuery
$DWDb=$Script:Datatable | ConvertTo-Html -Property Column1, Column2 -Fragment -PreContent "<h3>Data Warehouse \ Summary</h3>"
$DWDb=$DWDb -replace '<tr><th>Column1</th><th>Column2</th></tr>',''
$DWDb=$DWDb -replace '<td>No backup','<td class="Error">No backup'
$DWDb=$DWDb -replace '<td>Over 7 days - ','<td class="Warning">Over 7 days - '
$DWDb=$DWDb -replace '<td>ConfigIssue - Disabled','<td class="Error">Disabled'
<# CODE_SECTION_10
DWDb database file info.
#>
$CodeSection="10"
$DbQuery="USE $Script:DWDbName
SELECT 
CASE 
WHEN alias_smf.type=0 THEN 'Database'
ELSE 'Log'
END AS 'File Type',
FORMAT(alias_sysfiles.size/128,'N0') + ' MB' as 'File Size',
FORMAT((FILEPROPERTY(alias_sysfiles.name,'SpaceUsed')/128),'N0') + ' MB' AS 'Used Space', 
FORMAT((alias_sysfiles.size/128)-(FILEPROPERTY(alias_sysfiles.name,'SpaceUsed')/128),'N0') + ' MB' AS 'Free Space', 
CASE 
WHEN alias_smf.growth=0 THEN 'Disabled'
ELSE 'Enabled'
END AS 'Autogrow',
alias_smf.physical_name AS 'Filename',
alias_smf.name AS 'Logical Name'
FROM dbo.sysfiles alias_sysfiles
INNER JOIN sys.master_files alias_smf ON alias_sysfiles.filename=alias_smf.physical_name
ORDER BY file_id"
SQLQuery $Script:DwDbServer $Script:DWDbName $DbQuery
$DWDbFiles=$Script:Datatable | ConvertTo-Html -Property "File Type", "File Size", "Used Space", "Free Space", "Autogrow", "Filename", "Logical Name" -Fragment -PreContent "<h3>Data Warehouse \ Db Files</h3>"
$DWDbFiles=$DWDbFiles -replace '<td>Disabled','<td class="Error">Disabled'
<# CODE_SECTION_10
?
#>
$CodeSection="10"
<# CODE_SECTION_11
Update rollup info.
#>
$CodeSection="11"
$DbQuery="SELECT UPPER (DisplayName) As Computer
,AgentVersion_3AFB8DF2_255D_EF64_2996_AB381CA83F11 AS Agent
,[MgmtServerVersion_E8B08CCC_887D_3193_5AF3_01E1225E8799] AS ManagementServer
,[WebConsoleVersion_6EC692DE_61A1_190E_D016_A6D8039081C2] AS WebConsole
,[ReportServerVersion_A9D4505D_ADFE_5CF2_7E23_FFFC0ED131EB] AS ReportServer
,[GatewayServerVersion_C5C64EC6_1FAE_82EB_90BF_37D55CB4FF69] AS GatewayServer
,[ACSCollectorVersion_D788AA22_33A3_C547_BF37_5571B8416756] AS ACSCollector
,[ConsoleVersion_B993C88D_FD4E_DA45_4CD9_ABB39B7890CD] AS UIConsole
FROM [$Script:OpsDbName].[dbo].[MT_SCOM`$WindowsComputer]
ORDER BY Computer ASC"
SQLQuery $Script:OpsDbServer $Script:OpsDbName $DbQuery
$UpdateRollups=$Script:Datatable | Select-Object Computer,Agent,@{N='Management Server';E={$_.ManagementServer}},@{N='Web Console';E={$_.WebConsole}},@{N='Report Server';E={$_.ReportServer}},@{N='Gateway Server';E={$_.GatewayServer}},@{N='ACS Collector';E={$_.ACSCollector}},@{N='UI Console';E={$_.UIConsole}} | ConvertTo-Html -Property Computer, Agent,"Management Server","Web Console","Report Server","ACS Collector","Gateway Server","UI Console" -Fragment -PreContent "<h2><a id=UpdateRollups>Update Rollups</a></h2>"
$UpdateRollups=$UpdateRollups -replace '<td>Unknown version','<td class="Error">Unknown version'
# $UpdateRollups=$UpdateRollups -replace '<td>Update required','<td class="Warning">Update required' # 22.12.2021 not using anymore. Removed from agent discovery script.
<# CODE_SECTION_10
Finish generating report.
#>
$CodeSection="10"
$GenerationTime="<p>This report was generated on $ComputerFqdn by $User on $Start.</p>"
ConvertTo-HTML -Head $Head -Body "$H1SCOMReport $GenerationTime $H2Index $IndexButtonGroup $Summary $OpsDb $OpsDbFiles $DWDb $DWDbFiles $UpdateRollups $ExampleParagraph $IndexButton" | Out-File "$MgReportFolder\$MgName`_SCOM_Report.html"
<# FOR TESTING
Invoke-Item -Path "$MgReportFolder\$MgName`_SCOM_Report.html" # remove when done.
#>
} # end test report path.
LogAndQuit
}
Catch
{
TerminatingError
}
}
MgReport -MgReportFolder $MgReportFolder # Need this to pass params in properly.
# End MG Report
]]>
</ScriptBody>
<Parameters>
<Parameter>
<Name>ComputerName</Name>
<Value>$Config/ComputerName$</Value>
</Parameter>
<Parameter>
<Name>MgReportFolder</Name>
<Value>$Config/MgReportFolder$</Value>
</Parameter>			  
</Parameters>
<TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
</WriteAction>
</MemberModules>
<Composition>
<Node ID="WA" />
</Composition>
</Composite>
</ModuleImplementation>
<OutputType>System!System.BaseData</OutputType>
<InputType>System!System.BaseData</InputType>
</WriteActionModuleType>
<!--**************************************** GET LOG ANALYTICS WORKSPACES WRITE ACTION MODULE ****************************************-->
<WriteActionModuleType ID="SCOM.WAM.URGetLogAnalyticsWorkspace" Accessibility="Internal" Batching="false">
<Configuration>
<xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
</Configuration>
<OverrideableParameters>
<OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
</OverrideableParameters>
<ModuleImplementation Isolation="Any">
<Composite>
<MemberModules>
<WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
<ScriptName>SCOM.GetLogAnalyticsWorkspace.ps1</ScriptName>
<ScriptBody><![CDATA[
Function FoundNone {
$Script:Output="No Log Analytics workspaces found."
}
Function GetLAWorkspaces {
$ComputerFqdn=([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname
Write-Host "====================================="
Write-Host "Task: Get Log Analytics workspaces"
Write-Host "Computer: $ComputerFqdn"
Write-Host "====================================="
Write-Host
$LAWorkspaceRegKey="HKLM:\SYSTEM\CurrentControlSet\Services\HealthService\Parameters\Service Connector Services"
If (Test-Path $LAWorkspaceRegKey) {
$BindLAWorkspaceRegKey=Get-Item $LAWorkspaceRegKey
$LAWorkspaceCount=($BindLAWorkspaceRegKey).SubKeyCount
If ($LAWorkspaceCount -gt 0) {
$ArrayLAWorkspaces=$BindLAWorkspaceRegKey.GetSubKeyNames()
$ArrayLAWorkspaces | ForEach-Object {
$LAWorkspaceId=$_.Substring(16)
$LAWorkspaceTypeId=(Get-ItemProperty -Path $LAWorkspaceRegKey\$_)."Azure Cloud Type"
Switch ($LAWorkspaceTypeId) {
"0" {$LAWorkspaceType="Azure Commercial"; BREAK}
"1" {$LAWorkspaceType="Azure US Government"; BREAK}
"2" {$LAWorkspaceType="Azure China"; BREAK}
"3" {$LAWorkspaceType="Azure US Nat"; BREAK}
"4" {$LAWorkspaceType="Azure US Sec"; BREAK}
Default {
$LAWorkspaceType="Unknown"
}
}
$LAWorkspaceConnectionStatusId=(Get-ItemProperty -Path $LAWorkspaceRegKey\$_)."Connection Status"
If ($LAWorkspaceConnectionStatusId -eq 0) {
$LAWorkspaceConnectionStatus="Connected"
}
Else {
$LAWorkspaceConnectionStatus="Unknown"
}
$Output+="Workspace Id: $LAWorkspaceId`nCloud Type: $LAWorkspaceTypeId ($LAWorkspaceType)`nConnection Status: $LAWorkspaceConnectionStatusId ($LAWorkspaceConnectionStatus)`n`n"
} # END FOR
}
Else {
FoundNone
}
}
Else {
FoundNone
}
Write-Host $Output
}
GetLAWorkspaces
]]>
</ScriptBody>
<Parameters>
</Parameters>
<TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
</WriteAction>
</MemberModules>
<Composition>
<Node ID="PSWA" />
</Composition>
</Composite>
</ModuleImplementation>
<OutputType>System!System.BaseData</OutputType>
<InputType>System!System.BaseData</InputType>
</WriteActionModuleType>
<!--**************************************** GET TLS1.2 REGISTRY WRITE ACTION MODULE ****************************************-->
<WriteActionModuleType ID="SCOM.WAM.GetTLSRegSettings" Accessibility="Internal" Batching="false">
<Configuration>
<xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
</Configuration>
<OverrideableParameters>
<OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
</OverrideableParameters>
<ModuleImplementation Isolation="Any">
<Composite>
<MemberModules>
<WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
<ScriptName>SCOM.GetTLSRegSettings.ps1</ScriptName>
<ScriptBody><![CDATA[
Function CheckNull ($PassedInParam) {
If ([string]::IsNullOrEmpty($PassedInParam)) {
$Script:Message+="[WARNING] Missing value name: $_\$ValueToCheck`n"
}
Else {
$Script:Message+="[INFO] Found value: $_\$ValueToCheck=$PassedInParam`n"
}
}
Function RunScript {
$ComputerFqdn=([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname
Write-Host "====================================="
Write-Host "Task: Get TLS1.2 registry settings"
Write-Host "Computer: $ComputerFqdn"
Write-Host "====================================="
Write-Host
$ArrayTLS12NETEnabled="HKLM:\SOFTWARE\Microsoft\.NETFramework\v4.0.30319","HKLM:\SOFTWARE\WOW6432Node\Microsoft\.NETFramework\v4.0.30319"
$ArrayTLS12NETEnabled | ForEach-Object {
$Count+=1
If (Test-Path -Path $_) {
$SchUseStrongCrypto=(Get-ItemProperty $_).SchUseStrongCrypto
}
$ValueToCheck="SchUseStrongCrypto"; CheckNull $SchUseStrongCrypto
}
$ArrayTLS12OSRegKey="HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.2\Client","HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.2\Server"
$ArrayTLS12OSRegKey | ForEach-Object {
If (Test-Path -Path $_) {
$Enabled=(Get-ItemProperty $_).Enabled
$DisabledByDefault=(Get-ItemProperty $_).DisabledByDefault
}
$ValueToCheck="Enabled"; CheckNull $Enabled
$ValueToCheck="DisabledByDefault"; CheckNull $DisabledByDefault
}
$Script:Message
}
RunScript
]]>
</ScriptBody>
<Parameters>
</Parameters>
<TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
</WriteAction>
</MemberModules>
<Composition>
<Node ID="PSWA" />
</Composition>
</Composite>
</ModuleImplementation>
<OutputType>System!System.BaseData</OutputType>
<InputType>System!System.BaseData</InputType>
</WriteActionModuleType>
<!--**************************************** GET WINDOWS SERVICES WRITE ACTION MODULE ****************************************-->
<WriteActionModuleType ID="SCOM.WAM.URGetWindowsServices" Accessibility="Internal" Batching="false">
<Configuration>
<xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
</Configuration>
<OverrideableParameters>
<OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
</OverrideableParameters>
<ModuleImplementation Isolation="Any">
<Composite>
<MemberModules>
<WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
<ScriptName>SCOM.GetWindowsServices.ps1</ScriptName>
<ScriptBody><![CDATA[
$ComputerFqdn=([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname
Write-Host "====================================="
Write-Host "Task: Get Windows services"
Write-Host "Computer: $ComputerFqdn"
Write-Host "====================================="
Write-Host
Write-Host "Note: Services have been sorted by the DisplayName property."
Write-Host
$Services=Get-WmiObject Win32_Service | Sort-Object DisplayName | Select-Object -Property DisplayName,Name,State,StartMode,StartName,ProcessId
$Services | ForEach-Object {
$DisplayName=$_.DisplayName
$Name=$_.Name
$State=$_.State
$StartMode=$_.StartMode
$StartName=$_.StartName
$ProcessId=$_.ProcessId
$Output+="DISPLAY_NAME: $DisplayName`nSERVICE_NAME: $Name`nSTATUS: $State`nStartMode_TYPE: $StartMode`nLOG_ON_ACCOUNT: $StartName`nPROCESS_ID: $ProcessId`n`n"
}
$Output
]]>
</ScriptBody>
<Parameters>
</Parameters>
<TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
</WriteAction>
</MemberModules>
<Composition>
<Node ID="PSWA" />
</Composition>
</Composite>
</ModuleImplementation>
<OutputType>System!System.BaseData</OutputType>
<InputType>System!System.BaseData</InputType>
</WriteActionModuleType>
<!--**************************************** GET WINDOWS DISK VOLUMES WRITE ACTION MODULE ****************************************-->
<WriteActionModuleType ID="SCOM.WAM.URGetWindowsDiskInfo" Accessibility="Internal" Batching="false">
<Configuration>
<xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
</Configuration>
<OverrideableParameters>
<OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
</OverrideableParameters>
<ModuleImplementation Isolation="Any">
<Composite>
<MemberModules>
<WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
<ScriptName>SCOM.GetWindowsDiskInfo.ps1</ScriptName>
<ScriptBody><![CDATA[
$ComputerFqdn=([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname
$PSVersion=$PSVersionTable.PSVersion
$PSMajor=$PSVersion.Major
$PSMinor=$PSVersion.Minor
$PSVersion="$PSMajor.$PSMinor"
$Output+="Task: Get disk info`n"
$Output+="Computer: $ComputerFqdn`n"
$Output+="PowerShell Version: $PSVersion`n`n"
Set-Variable -Name "CONVERSION_FACTOR" -Value "1073741824"
Set-Variable -Name "FIXED_DISK" -Value "3"
$Volumes=Get-WmiObject Win32_Volume | Where-Object {$_.DriveType -eq $FIXED_DISK} | Sort-Object Name
$Volumes | ForEach-Object {
$Name=$_.Name
$Label=$_.Label
$DriveType=$_.DriveType
Switch ($DriveType) {
"0" {$DriveType="Unknown"; BREAK}
"1" {$DriveType="No Root Directory"; BREAK}
"2" {$DriveType="Removable Disk"; BREAK}
"3" {$DriveType="Local Disk"; BREAK}
"4" {$DriveType="Network Drive"; BREAK}
"5" {$DriveType="Compact Disc"; BREAK}
"6" {$DriveType="RAM Disk"; BREAK}
Default {$DriveType="Unknown"}
}
$FileSystem=$_.FileSystem
$VolumeCapacity="{0:n2}" -f ($_.Capacity / $CONVERSION_FACTOR)
$VolumeUsedSpace="{0:n2}" -f (($_.Capacity - $_.FreeSpace) / $CONVERSION_FACTOR)
$VolumeFreeSpace="{0:n2}" -f ($_.FreeSpace / $CONVERSION_FACTOR)
$DirtyBitSet=$_.DirtyBitSet
$Output+="VOLUME_NAME: $Name`nVOLUME_LABEL: $Label`nDRIVE_TYPE: $DriveType`nFILE_SYSTEM: $FileSystem`nCAPACITY: $VolumeCapacity GB`nUSED_SPACE: $VolumeUsedSpace GB`nFREE_SPACE: $VolumeFreeSpace GB`nDIRTY_BIT_SET: $DirtyBitSet   `n`n"
}
$Output
]]>
</ScriptBody>
<Parameters>
</Parameters>
<TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
</WriteAction>
</MemberModules>
<Composition>
<Node ID="PSWA" />
</Composition>
</Composite>
</ModuleImplementation>
<OutputType>System!System.BaseData</OutputType>
<InputType>System!System.BaseData</InputType>
</WriteActionModuleType>
<!--**************************************** RESET AGENT HEALTH WRITE ACTION MODULE ****************************************-->
<WriteActionModuleType ID="Microsoft.SystemCenter.ResetServiceStoreAction" Comment="Request Health Service Store Reset" Accessibility="Internal" Batching="false">
<Configuration />
<ModuleImplementation Isolation="Any">
<Native>
<ClassID>B253A4FA-71BE-4F5D-94D5-A46B0D2505AA</ClassID>
</Native>
</ModuleImplementation>
<InputType>System!System.BaseData</InputType>
</WriteActionModuleType>
<!--**************************************** LOG WINDOWS TEST EVENT WRITE ACTION MODULE ****************************************-->
<WriteActionModuleType ID="SCOM.WAM.URTask.LogWindowsTestEvent" Accessibility="Internal" Batching="false">
<Configuration>
<xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
</Configuration>
<OverrideableParameters>
<OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
</OverrideableParameters>
<ModuleImplementation Isolation="Any">
<Composite>
<MemberModules>
<WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
<ScriptName>LogWindowsTestEvent.ps1</ScriptName>
<ScriptBody><![CDATA[
try{
$ObjMomApi=New-Object -comObject 'MOM.ScriptAPI' # MOMScriptAPI object.
$ComputerFqdn=([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname
Write-Host "====================================="
Write-Host "Task: Log Windows Test Event"
Write-Host "Computer: $ComputerFqdn"
Write-Host "====================================="
Write-Host
$EventId=17616
$EventLevel=0 # 0=Information, 1=Error, 2=Warning
# Use MOMScriptAPI.LogScriptEvent method to log events because Write-EventLog doesn't work on new OSs.
$ObjMomApi.LogScriptEvent("LogWindowsTestEvent.ps1", $EventId, $EventLevel, "This is a test alert to check agent functionality. It is generated by running the 'Log Test Event' SCOM task.`nManagement Pack: SCOM.UpdateRollup (2023.3.21.0)")
Write-Host Information event ID 17616 successfully written to the Operations Manager log.
Write-Host
} catch {
Write-Host "Error:" $_.Exception.Message
Write-Host
}
]]>
</ScriptBody>
<Parameters>
</Parameters>
<TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
</WriteAction>
</MemberModules>
<Composition>
<Node ID="PSWA" />
</Composition>
</Composite>
</ModuleImplementation>
<OutputType>System!System.BaseData</OutputType>
<InputType>System!System.BaseData</InputType>
</WriteActionModuleType>
</ModuleTypes>
</TypeDefinitions>
<!--**************************************** RUN BUILT-IN TASKS ****************************************-->
<Categories>
<Category ID="SCOM.CategoryPingTask" Target="SCOM.Task.Ping" Value="System!System.Internal.ManagementPack.ConsoleTasks.MonitoringObject" />
<Category ID="SCOM.CategoryRDPTask" Target="SCOM.Task.RDP" Value="System!System.Internal.ManagementPack.ConsoleTasks.MonitoringObject" />
</Categories>
<Monitoring>
<!--**************************************** DISCOVERIES ****************************************-->
<Discoveries>
<Discovery ID="SCOM.Discovery.WindowsComputer" Target="SystemCenter!Microsoft.SystemCenter.HealthService" Enabled="true" ConfirmDelivery="false" Remotable="true" Priority="Normal">
<Category>Discovery</Category>
<DiscoveryTypes>
<DiscoveryClass TypeID="SCOM.Class.URWindowsComputer">
<Property PropertyID="OperatingSystem"/>
<Property PropertyID="Product"/>
<Property PropertyID="AgentInstallDirectory"/>
<Property PropertyID="AgentLastUpdate"/>
<Property PropertyID="AgentVersion"/>
<!--
<Property PropertyID="AgentMGCount"/>
<Property PropertyID="AgentMGFailovers"/>
-->
<Property PropertyID="MGCount"/>
<Property PropertyID="MGNames"/>
<Property PropertyID="HealthServiceAccount"/>
<Property PropertyID="HealthServiceStartMode"/>
<Property PropertyID="CertificateExpiry"/>
<Property PropertyID="ADIntegration"/>
<Property PropertyID="APMInstalled"/>
<Property PropertyID="APMServiceAccount"/>
<Property PropertyID="APMServiceStartMode"/>
<Property PropertyID="ACSForwarderServiceAccount"/>
<Property PropertyID="ACSForwarderServiceStartMode"/>
<Property PropertyID="TLS12"/>
<Property PropertyID="LAWorkspaceCount"/>
<Property PropertyID="LAWorkspaces"/>
<Property PropertyID="LAProxyUrl"/>
<Property PropertyID="LAProxyUsername"/>
<Property PropertyID="ComputerType"/>
<Property PropertyID="MgmtServerInstallDirectory"/>
<Property PropertyID="MgmtServerLastUpdate"/>
<Property PropertyID="MgmtServerVersion"/>
<Property PropertyID="ConfigServiceAccount"/>
<Property PropertyID="ConfigServiceStartMode"/>
<Property PropertyID="DataAccessServiceAccount"/>
<Property PropertyID="DataAccessServiceStartMode"/>
<Property PropertyID="OpsDbName"/>
<Property PropertyID="OpsDbServer"/>
<Property PropertyID="DWDbName"/>
<Property PropertyID="DwDbServer"/>
<Property PropertyID="ACSCollector"/>
<Property PropertyID="ACSCollectorServiceAccount"/>
<Property PropertyID="ACSCollectorServiceStartMode"/>
<Property PropertyID="ACSCollectorLastUpdate"/>
<Property PropertyID="ACSCollectorVersion"/>
<Property PropertyID="RMS"/>
<Property PropertyID="GatewayServerInstallDirectory"/>
<Property PropertyID="GatewayServerLastUpdate"/>
<Property PropertyID="GatewayServerVersion"/>
<!--
<Property PropertyID="GatewayMGCount"/>
<Property PropertyID="GatewayMGFailovers"/>
-->
<Property PropertyID="WebConsoleInstallDirectory"/>
<Property PropertyID="WebConsoleLastUpdate"/>
<Property PropertyID="WebConsoleVersion"/>
<Property PropertyID="AuthenticationMode"/>
<Property PropertyID="DefaultServer"/>
<Property PropertyID="WebConsoleUrl"/>
<Property PropertyID="ApmAdvisorUrl"/>
<Property PropertyID="ApmDiagnosticsUrl"/>
<Property PropertyID="ReportServerInstallDirectory"/>
<Property PropertyID="ReportServerLastUpdate"/>
<Property PropertyID="ReportServerVersion"/>
<Property PropertyID="ReportServerDwDbServer"/>
<Property PropertyID="ReportServerDWDBName"/>
<Property PropertyID="ReportServerUrl"/>
<Property PropertyID="SRSInstance"/>
<Property PropertyID="ReportServerServiceAccount"/>
<Property PropertyID="ReportServerServiceStartMode"/>
<Property PropertyID="ConsoleInstallDirectory"/>
<Property PropertyID="ConsoleLastUpdate"/>
<Property PropertyID="ConsoleVersion"/>
</DiscoveryClass>
</DiscoveryTypes>
<DataSource ID="DS" TypeID="SCOM.DSM.URWindowsComputer">
<IntervalSeconds>86400</IntervalSeconds>
<SyncTime></SyncTime>
<TimeoutSeconds>120</TimeoutSeconds>
</DataSource>
</Discovery>
</Discoveries>
<!--**************************************** RULES ****************************************-->
<Rules>
<!--Daily report rule-->
<Rule ID="SCOM.Rule.DailyReport" Enabled="false" Target="SystemCenter!Microsoft.SystemCenter.RootManagementServer" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
<Category>Maintenance</Category>
<DataSources>
  <DataSource ID="DS" TypeID="System!System.Scheduler">
	<Scheduler>
	  <SimpleReccuringSchedule>
		<Interval Unit="Seconds">86400</Interval> <!-- 86400 daily default -->
		<SyncTime>08:00</SyncTime> <!-- 8am -->
	  </SimpleReccuringSchedule>
	  <ExcludeDates />
	</Scheduler>
  </DataSource>
</DataSources>
<WriteActions>
  <WriteAction ID="WA" TypeID="SCOM.WAM.URDailyReport">
	<EmailFromAddress>from@email.address</EmailFromAddress>
	<EmailToAddress>one@email.address,two@email.address</EmailToAddress>
	<EmailServer>Smtp.server</EmailServer>
	<EmailPort>Smtp.port</EmailPort>
	<Identifier></Identifier>
	<TimeoutSeconds>120</TimeoutSeconds>
  </WriteAction>
</WriteActions>
</Rule>
<!--Alert Management rule-->
<Rule ID="SCOM.Rule.AlertManagement" Enabled="false" Target="SystemCenter!Microsoft.SystemCenter.RootManagementServer" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
<Category>Maintenance</Category>
<DataSources>
<DataSource ID="Scheduler" TypeID="SCOM.DSM.URAlertManagement">
<IntervalSeconds>300</IntervalSeconds> <!-- 5 minutes -->
<SyncTime></SyncTime>
</DataSource>	  
</DataSources>		
<WriteActions>
<WriteAction ID="WA" TypeID="SCOM.WAM.URAlertManagement">
<!--
<ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</ComputerName>
<MpBackupFolder></MpBackupFolder>
-->
<TimeoutSeconds>120</TimeoutSeconds>
</WriteAction>
</WriteActions>
</Rule>
<!--Alert Management Script. Used a rule here because we need to see alerts details so can't have it auto close.-->
<Rule ID="SCOM.Rule.AlertManagementScript" Enabled="false" Target="SystemCenter!Microsoft.SystemCenter.RootManagementServer" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
<Category>Alert</Category>
<DataSources>
<DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
<ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
<LogName>Operations Manager</LogName>
<Expression>
<And>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="UnsignedInteger">17618</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="String">PublisherName</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="String">Health Service Script</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
</And>
</Expression>
</DataSource>
</DataSources>
<WriteActions>
<WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
<Priority>2</Priority>
<Severity>1</Severity>
<AlertName />
<AlertDescription />
<AlertOwner />
<AlertMessageId>$MPElement[Name="SCOM.Rule.AlertManagementScript.AlertMessage"]$</AlertMessageId>
<AlertParameters>
<AlertParameter1>$Data/EventDescription$</AlertParameter1>
</AlertParameters>
<Suppression />
<Custom1 />
<Custom2 />
<Custom3 />
<Custom4 />
<Custom5 />
<Custom6 />
<Custom7 />
<Custom8 />
<Custom9 />
<Custom10 />
</WriteAction>
</WriteActions>
</Rule>
<!--Mp backup rule-->
<Rule ID="SCOM.Rule.MpBackup" Enabled="false" Target="SCOM.Class.URWindowsComputer" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
<Category>Maintenance</Category>
<DataSources>
<DataSource ID="Scheduler" TypeID="SCOM.DSM.URMpBackup">
<IntervalSeconds>86400</IntervalSeconds>
<SyncTime></SyncTime>
</DataSource>	  
</DataSources>		
<WriteActions>
<WriteAction ID="WA" TypeID="SCOM.WAM.URMpBackup">
<ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</ComputerName>
<MpBackupFolder></MpBackupFolder> <!--LEAVE BLANK-->
<TimeoutSeconds>120</TimeoutSeconds>
</WriteAction>
</WriteActions>
</Rule>
<!--Mg report rule-->
<Rule ID="SCOM.Rule.MgReport" Enabled="false" Target="SCOM.Class.URWindowsComputer" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
<Category>Maintenance</Category>
<DataSources>
<DataSource ID="Scheduler" TypeID="SCOM.URMgReport">
<IntervalSeconds>86400</IntervalSeconds>
<SyncTime></SyncTime>
</DataSource>	  
</DataSources>		
<WriteActions>
<WriteAction ID="WA" TypeID="SCOM.WAM.URMgReport">
<ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</ComputerName>
<MgReportFolder></MgReportFolder> <!--LEAVE BLANK-->
<TimeoutSeconds>120</TimeoutSeconds>
</WriteAction>
</WriteActions>
</Rule>
<!--new-->
<Rule ID="SCOM.Rule.AlertOnLogWindowsTestEvent" Enabled="true" Target="SCOM.Class.URWindowsComputer" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
<Category>Alert</Category>
<DataSources>
<DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
<ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</ComputerName>
<LogName>Operations Manager</LogName>
<Expression>
<And>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="UnsignedInteger">17616</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="String">PublisherName</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="String">Health Service Script</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
<Expression>
</Expression>
</And>
</Expression>
</DataSource>
</DataSources>
<WriteActions>
<WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
<Priority>0</Priority> <!--Low-->
<Severity>0</Severity> <!--Information-->
<AlertName />
<AlertDescription />
<AlertOwner />
<AlertMessageId>$MPElement[Name="SCOM.Rule.AlertOnLogWindowsTestEvent.AlertMessage"]$</AlertMessageId>
<AlertParameters>
<AlertParameter1>$Data/EventDescription$</AlertParameter1>
</AlertParameters>
<Suppression/>
<Custom1 />
<Custom2 />
<Custom3 />
<Custom4 />
<Custom5 />
<Custom6 />
<Custom7 />
<Custom8 />
<Custom9 />
<Custom10 />
</WriteAction>
</WriteActions>
</Rule>
<!-- end new -->
</Rules>
<!--**************************************** TASKS ****************************************-->
<Tasks>
<!--Run command-->
<Task ID="SCOM.Task.RunCommand" Accessibility="Public" Enabled="true" Target="SCOM.Class.URWindowsComputer" Timeout="120" Remotable="true">
<Category>Maintenance</Category>
<WriteAction ID="PSWA" TypeID="SCOM.WAM.RunCommand">
<TimeoutSeconds>60</TimeoutSeconds>
<RunCommand></RunCommand>
</WriteAction>
</Task>	
<!--Get log analytics workspaces-->
<Task ID="SCOM.Task.GetLogAnalyticsWorkspace" Accessibility="Public" Enabled="true" Target="SCOM.Class.URWindowsComputer" Timeout="120" Remotable="true">
<Category>Maintenance</Category>
<WriteAction ID="PSWA" TypeID="SCOM.WAM.URGetLogAnalyticsWorkspace">
<TimeoutSeconds>180</TimeoutSeconds>
</WriteAction>
</Task>
<!--Get TLS reg setting-->
<Task ID="SCOM.Task.GetTLSRegSettings" Accessibility="Public" Enabled="true" Target="SCOM.Class.URWindowsComputer" Timeout="120" Remotable="true">
<Category>Maintenance</Category>
<WriteAction ID="PSWA" TypeID="SCOM.WAM.GetTLSRegSettings">
<TimeoutSeconds>180</TimeoutSeconds>
</WriteAction>
</Task>
<!--Get windows services-->
<Task ID="SCOM.Task.GetWindowsServices" Accessibility="Public" Enabled="true" Target="SCOM.Class.URWindowsComputer" Timeout="120" Remotable="true">
<Category>Maintenance</Category>
<WriteAction ID="PSWA" TypeID="SCOM.WAM.URGetWindowsServices">
<TimeoutSeconds>180</TimeoutSeconds>
</WriteAction>
</Task>
<!--Get windows disk info-->
<Task ID="SCOM.Task.GetWindowsDiskInfo" Accessibility="Public" Enabled="true" Target="SCOM.Class.URWindowsComputer" Timeout="120" Remotable="true">
<Category>Maintenance</Category>
<WriteAction ID="PSWA" TypeID="SCOM.WAM.URGetWindowsDiskInfo">
<TimeoutSeconds>180</TimeoutSeconds>
</WriteAction>
</Task>
<!--Reset health-->
<Task ID="SCOM.Task.ResetHealth" Comment="Request Health Service Store Reset" Accessibility="Internal" Enabled="true" Target="SCOM.Class.URWindowsComputer" Timeout="300" Remotable="true">
<Category>Maintenance</Category>
<WriteAction ID="ResetServiceStore" TypeID="Microsoft.SystemCenter.ResetServiceStoreAction" />
</Task>
<!--Log windows test event-->
<Task ID="SCOM.Task.LogWindowsTestEvent" Accessibility="Public" Enabled="true" Target="SCOM.Class.URWindowsComputer" Timeout="120" Remotable="true">
<Category>Maintenance</Category>
<WriteAction ID="PSWA" TypeID="SCOM.WAM.URTask.LogWindowsTestEvent">
<TimeoutSeconds>180</TimeoutSeconds>
</WriteAction>
</Task>
<!--Remove management groups-->
<Task ID="SCOM.Task.RemoveMgmtGroup" Accessibility="Public" Enabled="true" Target="SCOM.Class.URWindowsComputer" Timeout="120" Remotable="true">
<Category>Maintenance</Category>
<WriteAction ID="PSWA" TypeID="SCOM.WAM.URRemoveMgmtGroup">
<ManagementGroups></ManagementGroups>
<TimeoutSeconds>180</TimeoutSeconds>
</WriteAction>
</Task>

</Tasks>
<!--**************************************** MONITORS ****************************************-->
<Monitors>
<UnitMonitor ID="SCOM.Monitor.WindowsInventoryScript" Accessibility="Public" Enabled="true" Target="SCOM.Class.URWindowsComputer" ParentMonitorID="Health!System.Health.ConfigurationState" Remotable="true" Priority="Normal" TypeID="Windows!Microsoft.Windows.2SingleEventLog2StateMonitorType" ConfirmDelivery="true">
<Category>Maintenance</Category>

<!-- 18/7/2022 - Remove comment when you have fixed agent alerts.
<AlertSettings AlertMessage="SCOM.Monitor.WindowsInventoryScript.AlertMessage">
<AlertOnState>Warning</AlertOnState>
<AutoResolve>true</AutoResolve>
<AlertPriority>Low</AlertPriority>
<AlertSeverity>Information</AlertSeverity>
<AlertParameters>
<AlertParameter1>$Data/Context/EventDescription$</AlertParameter1>
</AlertParameters>
</AlertSettings>
-->

<OperationalStates>
<OperationalState ID="OpsStateWarning" MonitorTypeStateID="FirstEventRaised" HealthState="Warning" />
<OperationalState ID="OpsStateHealthy" MonitorTypeStateID="SecondEventRaised" HealthState="Success" />
</OperationalStates>
<Configuration>
<FirstComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</FirstComputerName>
<FirstLogName>Operations Manager</FirstLogName>
<FirstExpression>
<And>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="UnsignedInteger">17611</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="String">PublisherName</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="String">Health Service Script</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
</And>
</FirstExpression>
<SecondComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</SecondComputerName>
<SecondLogName>Operations Manager</SecondLogName>
<SecondExpression>
<And>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="UnsignedInteger">17610</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="String">PublisherName</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="String">Health Service Script</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
</And>
</SecondExpression>
</Configuration>
</UnitMonitor>
<UnitMonitor ID="SCOM.Monitor.AlertManagementMissedEvent" Accessibility="Public" Enabled="false" Target="SystemCenter!Microsoft.SystemCenter.RootManagementServer" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" TypeID="Windows!Microsoft.Windows.MissingEventLogSingleEventLog2StateMonitorType" ConfirmDelivery="true">
<Category>Alert</Category>
<AlertSettings AlertMessage="SCOM.Monitor.AlertManagementMissedEvent.AlertMessage">
<AlertOnState>Error</AlertOnState>
<AutoResolve>true</AutoResolve>
<AlertPriority>Normal</AlertPriority>
<AlertSeverity>Error</AlertSeverity>
</AlertSettings>
<OperationalStates>
<OperationalState ID="OpsStateHealthy" MonitorTypeStateID="EventRaised" HealthState="Success" />
<OperationalState ID="OpsStateError" MonitorTypeStateID="MissingEventRaised" HealthState="Error" />
</OperationalStates>
<Configuration>
<ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
<LogName>Operations Manager</LogName>
<Expression>
<And>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="UnsignedInteger">17617</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="String">PublisherName</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="String">Health Service Script</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
</And>
</Expression>
<MissingComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</MissingComputerName>
<MissingLogName>Operations Manager</MissingLogName>
<MissingExpression>
<And>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="UnsignedInteger">17617</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="String">PublisherName</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="String">Health Service Script</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
</And>
</MissingExpression>
<Consolidator>
<ConsolidationProperties />
<TimeControl>
<GenericSchedule>
<SimpleReccuringSchedule>
<Interval Unit="Minutes">10</Interval>
</SimpleReccuringSchedule>
<ExcludeDates />
</GenericSchedule>
</TimeControl>
<CountingCondition>
<CountMode>OnNewItemNOP_OnTimerOutputRestart</CountMode>
</CountingCondition>
</Consolidator>
</Configuration>
</UnitMonitor>
<UnitMonitor ID="SCOM.Monitor.MpBackup" Accessibility="Public" Enabled="false" Target="SCOM.Class.URWindowsComputer" ParentMonitorID="Health!System.Health.ConfigurationState" Remotable="true" Priority="Normal" TypeID="Windows!Microsoft.Windows.2SingleEventLog2StateMonitorType" ConfirmDelivery="true">
<Category>Maintenance</Category>
<AlertSettings AlertMessage="SCOM.Monitor.MpBackup.AlertMessage">
<AlertOnState>Warning</AlertOnState>
<AutoResolve>true</AutoResolve>
<AlertPriority>Low</AlertPriority>
<AlertSeverity>Information</AlertSeverity>
<AlertParameters>
<AlertParameter1>$Data/Context/EventDescription$</AlertParameter1>
</AlertParameters>
</AlertSettings>
<OperationalStates>
<OperationalState ID="OpsStateWarning" MonitorTypeStateID="FirstEventRaised" HealthState="Warning" />
<OperationalState ID="OpsStateHealthy" MonitorTypeStateID="SecondEventRaised" HealthState="Success" />
</OperationalStates>
<Configuration>
<FirstComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</FirstComputerName>
<FirstLogName>Operations Manager</FirstLogName>
<FirstExpression>
<And>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="UnsignedInteger">17613</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="String">PublisherName</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="String">Health Service Script</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
</And>
</FirstExpression>
<SecondComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</SecondComputerName>
<SecondLogName>Operations Manager</SecondLogName>
<SecondExpression>
<And>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="UnsignedInteger">17612</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="String">PublisherName</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="String">Health Service Script</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
</And>
</SecondExpression>
</Configuration>
</UnitMonitor>
<UnitMonitor ID="SCOM.Monitor.MgReport" Accessibility="Public" Enabled="false" Target="SCOM.Class.URWindowsComputer" ParentMonitorID="Health!System.Health.ConfigurationState" Remotable="true" Priority="Normal" TypeID="Windows!Microsoft.Windows.2SingleEventLog2StateMonitorType" ConfirmDelivery="true">
<Category>Maintenance</Category>
<AlertSettings AlertMessage="SCOM.Monitor.MgReport.AlertMessage">
<AlertOnState>Warning</AlertOnState>
<AutoResolve>true</AutoResolve>
<AlertPriority>Low</AlertPriority>
<AlertSeverity>Information</AlertSeverity>
<AlertParameters>
<AlertParameter1>$Data/Context/EventDescription$</AlertParameter1>
</AlertParameters>
</AlertSettings>
<OperationalStates>
<OperationalState ID="OpsStateWarning" MonitorTypeStateID="FirstEventRaised" HealthState="Warning" />
<OperationalState ID="OpsStateHealthy" MonitorTypeStateID="SecondEventRaised" HealthState="Success" />
</OperationalStates>
<Configuration>
<FirstComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</FirstComputerName>
<FirstLogName>Operations Manager</FirstLogName>
<FirstExpression>
<And>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="UnsignedInteger">17615</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="String">PublisherName</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="String">Health Service Script</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
</And>
</FirstExpression>
<SecondComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</SecondComputerName>
<SecondLogName>Operations Manager</SecondLogName>
<SecondExpression>
<And>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="UnsignedInteger">17614</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
<Expression>
<SimpleExpression>
<ValueExpression>
<XPathQuery Type="String">PublisherName</XPathQuery>
</ValueExpression>
<Operator>Equal</Operator>
<ValueExpression>
<Value Type="String">Health Service Script</Value>
</ValueExpression>
</SimpleExpression>
</Expression>
</And>
</SecondExpression>
</Configuration>
</UnitMonitor>
</Monitors>
<!--<Overrides>
</Overrides>
-->
</Monitoring>
<Presentation>
<!--**************************************** CONSOLE TASKS ****************************************-->
<ConsoleTasks>
<ConsoleTask ID="SCOM.Task.Ping" Accessibility="Internal" Enabled="true" Target="SCOM.Class.URWindowsComputer" RequireOutput="true">
<Assembly>Resource.SCOM.Task.Ping</Assembly>
<Handler>ShellHandler</Handler>
<Parameters>
<Argument Name="WorkingDirectory" />
<Argument Name="Application">%windir%\system32\ping.exe</Argument>
<Argument>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Argument>
</Parameters>
</ConsoleTask>
<ConsoleTask ID="SCOM.Task.RDP" Accessibility="Internal" Enabled="true" Target="SCOM.Class.URWindowsComputer" RequireOutput="false">
<Assembly>Resource.SCOM.Task.RDP</Assembly>
<Handler>ShellHandler</Handler>
<Parameters>
<Argument Name="WorkingDirectory" />
<Argument Name="Application">%windir%\system32\mstsc.exe</Argument>
<Argument>/v:</Argument>
<Argument>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$ /f</Argument>
</Parameters>
</ConsoleTask>
</ConsoleTasks>
<StringResources>
<StringResource ID="SCOM.Monitor.AlertManagementMissedEvent.AlertMessage" />
<StringResource ID="SCOM.Rule.AlertManagementScript.AlertMessage" />
<StringResource ID="SCOM.Monitor.WindowsInventoryScript.AlertMessage" />
<StringResource ID="SCOM.Monitor.MpBackup.AlertMessage" />
<StringResource ID="SCOM.Monitor.MgReport.AlertMessage" />
<StringResource ID="SCOM.Rule.AlertOnLogWindowsTestEvent.AlertMessage" />
</StringResources>
</Presentation>
<LanguagePacks>
<LanguagePack ID="ENU" IsDefault="true">
<DisplayStrings>
<!--**************************************** MANAGEMENT PACK ****************************************-->
<DisplayString ElementID="SCOM.UpdateRollup">
<Name>SCOM Update Rollup</Name>
<Description>Collects update rollup information on all SCOM components.</Description>
</DisplayString>
<!--Windows class-->
<DisplayString ElementID="SCOM.Class.URWindowsComputer">
<Name>Update Rollup Windows Computer</Name>
<Description>Used to collect inventory from Windows computers.</Description>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="OperatingSystem">
<Name>Operating System</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="Product">
<Name>Product</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="AgentInstallDirectory">
<Name>Agent Install Directory</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="AgentLastUpdate">
<Name>Agent Last Update (YMDT)</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="AgentVersion">
<Name>Agent Version</Name>
</DisplayString>
<!--
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="AgentMGCount">
<Name>Agent MG Count</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="AgentMGFailovers">
<Name>Agent MG Failovers</Name>
</DisplayString>
-->
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="MGCount">
<Name>MG Count</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="MGNames">
<Name>MG Names</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="HealthServiceAccount">
<Name>Health Service Account</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="HealthServiceStartMode">
<Name>Health Service Start Mode</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="CertificateExpiry">
<Name>Certificate Expiry (YMDT)</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="ADIntegration">
<Name>AD Integration</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="APMInstalled">
<Name>APM Installed</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="APMServiceAccount">
<Name>APM Service Account</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="APMServiceStartMode">
<Name>APM Service Start Mode</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="ACSForwarderServiceAccount">
<Name>ACS Forwarder Service Account</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="ACSForwarderServiceStartMode">
<Name>ACS Forwarder Service Start Mode</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="TLS12">
<Name>TLS 1.2</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="LAWorkspaceCount">
<Name>LA Workspace Count</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="LAWorkspaces">
<Name>LA Workspaces</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="LAProxyUrl">
<Name>LA ProxyUrl</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="LAProxyUsername">
<Name>LA Proxy Username</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="ComputerType">
<Name>Computer Type</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="MgmtServerInstallDirectory">
<Name>Mgmt Server Install Directory</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="MgmtServerLastUpdate">
<Name>Mgmt Server Last Update (YMDT)</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="MgmtServerVersion">
<Name>Mgmt Server Version</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="ConfigServiceAccount">
<Name>Config Service Account</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="ConfigServiceStartMode">
<Name>Config Service Start Mode</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="DataAccessServiceAccount">
<Name>Data Access Service Account</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="DataAccessServiceStartMode">
<Name>Data Access Service Start Mode</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="OpsDbName">
<Name>Operations Manager Db Name</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="OpsDbServer">
<Name>Operations Manager Db Server</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="DWDbName">
<Name>Data Warehouse Db Name</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="DwDbServer">
<Name>Data Warehouse Db Server</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="ACSCollector">
<Name>ACS Collector</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="ACSCollectorServiceAccount">
<Name>ACS Collector Service Account</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="ACSCollectorServiceStartMode">
<Name>ACS Collector Service Start Mode</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="ACSCollectorLastUpdate">
<Name>ACS Collector Last Update (YMDT)</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="ACSCollectorVersion">
<Name>ACS Collector Version</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="RMS">
<Name>RMS</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="GatewayServerInstallDirectory">
<Name>Gateway Server Install Directory</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="GatewayServerLastUpdate">
<Name>Gateway Server Last Update (YMDT)</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="GatewayServerVersion">
<Name>Gateway Server Version</Name>
</DisplayString>
<!--
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="GatewayMGCount">
<Name>Gateway MG Count</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="GatewayMGFailovers">
<Name>Gateway MG Failovers</Name>
</DisplayString>
-->
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="WebConsoleInstallDirectory">
<Name>Web Console Install Directory</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="WebConsoleLastUpdate">
<Name>Web Console Last Update (YMDT)</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="WebConsoleVersion">
<Name>Web Console Version</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="AuthenticationMode">
<Name>Authentication Mode</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="DefaultServer">
<Name>Default Server</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="WebConsoleUrl">
<Name>Web Console Url</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="ApmAdvisorUrl">
<Name>Apm Advisor Url</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="ApmDiagnosticsUrl">
<Name>Apm Diagnostics Url</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="ReportServerInstallDirectory">
<Name>Report Server Install Directory</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="ReportServerServiceAccount">
<Name>Report Server Service Account</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="ReportServerServiceStartMode">
<Name>Report Server Service Start Mode</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="ReportServerLastUpdate">
<Name>Report Server Last Update (YMDT)</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="ReportServerVersion">
<Name>Report Server Version</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="ReportServerDwDbServer">
<Name>Data Warehouse Db Server</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="ReportServerDWDBName">
<Name>Data Warehouse Db Name</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="ReportServerUrl">
<Name>Report Server Url</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="SRSInstance">
<Name>SRS Instance</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="ConsoleVersion">
<Name>Console Version</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="ConsoleInstallDirectory">
<Name>Console Install Directory</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Class.URWindowsComputer" SubElementID="ConsoleLastUpdate">
<Name>Console Last Update (YMDT)</Name>
</DisplayString>
<!--Discoveries-->
<DisplayString ElementID="SCOM.Discovery.WindowsComputer">
<Name>Windows Computer PowerShell Discovery</Name>
<Description>This script gets the properties of class 'SCOM.Class.URWindowsComputer'.</Description>
</DisplayString>
<!--Rules-->
<DisplayString ElementID="SCOM.Rule.DailyReport">
<Name>Daily Report</Name>
<Description>This rule runs a PowerShell script at 8am everyday that emails a summary of active alerts to selected recipients. For this rule to work 1)
Enable SCOM.Rule.AlertManagement rule. 2) Add Resolution state Name=Assigned, ID=1. 3) Configure overrides EmailFromAddress, EmailToAddress, EmailServer, EmailPort, Identifier</Description>
</DisplayString>
<DisplayString ElementID="SCOM.Rule.AlertManagement">
<Name>Alert Management</Name>
<Description>This rule runs a scheduled PowerShell script that updates alert properties on new alerts.</Description>
</DisplayString>
<DisplayString ElementID="SCOM.Rule.MpBackup">
<Name>Management Pack Backup</Name>
<Description />
</DisplayString>
<DisplayString ElementID="SCOM.Rule.MgReport">
<Name>Management Group Report</Name>
<Description />
</DisplayString>
<DisplayString ElementID="SCOM.Rule.AlertOnLogWindowsTestEvent">
<Name>Log Test Event</Name>
<Description>Generates an alert when event ID 17616 is detected in the Operations Manager log.</Description>
</DisplayString>
<DisplayString ElementID="SCOM.Rule.AlertOnLogWindowsTestEvent.AlertMessage">
<Name>Test Alert - Windows agent</Name>
<Description>{0}</Description>
</DisplayString>
<!--Monitors-->
<DisplayString ElementID="SCOM.Monitor.WindowsInventoryScript">
<Name>Windows Inventory Script</Name>
<Description>Monitors for errors or config issues generated by the SCOM.Discovery.WindowsComputer rule.</Description>
</DisplayString>
<DisplayString ElementID="SCOM.Monitor.WindowsInventoryScript" SubElementID="OpsStateHealthy">
<Name>Event Raised</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Monitor.WindowsInventoryScript" SubElementID="OpsStateWarning">
<Name>Missing Event Raised</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Monitor.WindowsInventoryScript.AlertMessage">
<Name>Windows inventory script</Name>
<Description>{0}</Description>
</DisplayString>
<DisplayString ElementID="SCOM.Monitor.AlertManagementMissedEvent">
<Name>Alert Management Missed Event</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Monitor.AlertManagementMissedEvent.AlertMessage">
<Name>Alert Management Missed Event</Name>
<Description>The 'SCOM.AlertManagement.ps1' script in rule 'SCOM.Rule.AlertManagement' has not completed successfully in the last 10 minutes.</Description>
</DisplayString>
<DisplayString ElementID="SCOM.Monitor.AlertManagementMissedEvent" SubElementID="OpsStateError">
<Name>Missing Event Raised</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Monitor.AlertManagementMissedEvent" SubElementID="OpsStateHealthy">
<Name>Event Raised</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Rule.AlertManagementScript">
<Name>Alert Management Script</Name>
<Description>This rule looks for events generated by the SCOM.Rule.AlertManagement rule on the RMS. Event criteria: Log=Operations Manager, Source=Health Service Script, Id=17618.</Description>
</DisplayString>
<DisplayString ElementID="SCOM.Rule.AlertManagementScript.AlertMessage">
<Name>Alert Management Script</Name>
<Description>{0}</Description>
</DisplayString>
<DisplayString ElementID="SCOM.Monitor.MpBackup">
<Name>Management Pack Backup</Name>
<Description>Monitors for errors generated by the SCOM.Rule.MpBackup rule.</Description>
</DisplayString>
<DisplayString ElementID="SCOM.Monitor.MpBackup" SubElementID="OpsStateHealthy">
<Name>Event Raised</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Monitor.MpBackup" SubElementID="OpsStateWarning">
<Name>Missing Event Raised</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Monitor.MpBackup.AlertMessage">
<Name>Management pack backup failed</Name>
<Description>{0}</Description>
</DisplayString>
<DisplayString ElementID="SCOM.Monitor.MgReport">
<Name>Management Group Report</Name>
<Description>Monitors for errors generated by the SCOM.Rule.MgReport rule.</Description>
</DisplayString>
<DisplayString ElementID="SCOM.Monitor.MgReport" SubElementID="OpsStateHealthy">
<Name>Event Raised</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Monitor.MgReport" SubElementID="OpsStateWarning">
<Name>Missing Event Raised</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Monitor.MgReport.AlertMessage">
<Name>Management group report failed</Name>
<Description>{0}</Description>
</DisplayString>
<!--Tasks-->
<DisplayString ElementID="SCOM.Task.RunCommand">
<Name>Run command</Name>
<Description>WARNING: This task will run any command line you specify.
Add the command and parameters as the override i.e. w32tm /query /status.</Description>
</DisplayString>
<DisplayString ElementID="SCOM.Task.RemoveMgmtGroup">
<Name>Remove Mgmt Group</Name>
<Description>Removes management groups using the agent configuration object (AgentConfigManager.MgmtSvcCfg) then cleans up leftover folders or reg keys. Enter a comma separated list of management groups in the ManagementGroups override. WARNING! This task restarts the HealthService.</Description>
</DisplayString>
<DisplayString ElementID="SCOM.Task.GetLogAnalyticsWorkspace">
<Name>Get Log Analytics workspaces</Name>
<Description>This task shows information about Log Analytics workspaces configured on the computer.</Description>
</DisplayString>
<DisplayString ElementID="SCOM.Task.GetTLSRegSettings">
<Name>Get TLS 1.2 registry settings</Name>
<Description>This task shows the state of the registry settings required for TLS 1.2.</Description>
</DisplayString>
<DisplayString ElementID="SCOM.Task.GetWindowsServices">
<Name>Get services</Name>
<Description>This task shows information about Windows services.</Description>
</DisplayString>
<DisplayString ElementID="SCOM.Task.GetWindowsDiskInfo">
<Name>Get disk info</Name>
<Description>This task shows information about fixed disks i.e. used/free space.</Description>
</DisplayString>
<DisplayString ElementID="SCOM.Task.ResetHealth">
<Name>Flush Cache</Name>
<Description>WARNING: Only run this task on agents. Do not run it on management servers or gateway servers.
This task will reset all state in the Health Service. This includes the state of rules, monitors, outgoing data, and cached management packs.  Since this task will reset the service, status of this task will not be delivered since outgoing task status is part of what is reset by this task. A warning event with Id 103 is logged to the Operations Manager log.</Description>
</DisplayString>
<DisplayString ElementID="SCOM.Task.LogWindowsTestEvent">
<Name>Log Test Event</Name>
<Description>This task is used to check agent functionality. It logs a test event (ID=17616) to the Operations Manager log on the selected computer. A rule will detect the event and generate an alert.</Description>
</DisplayString>
<DisplayString ElementID="SCOM.Task.Ping">
<Name>Ping</Name>
</DisplayString>
<DisplayString ElementID="SCOM.Task.RDP">
<Name>RDP</Name>
</DisplayString>
</DisplayStrings>
<KnowledgeArticles>
<KnowledgeArticle ElementID="SCOM.UpdateRollup" Visible="true">
<MamlContent>
<maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10"> <!-- I can't find where this is displayed in the UI -->
<maml:title>Test - Title</maml:title>
<maml:para>Line 1</maml:para>
<maml:para>Line 2</maml:para>
<maml:list>
<maml:listItem>
<maml:para>Bullet Point 1</maml:para>
</maml:listItem>
<maml:listItem>
<maml:para>Bullet Point 2</maml:para>
</maml:listItem>
<maml:listItem>
<maml:para>Bullet Point 3</maml:para>
</maml:listItem>
</maml:list>
</maml:section>
</MamlContent>
</KnowledgeArticle>
<KnowledgeArticle ElementID="SCOM.Monitor.WindowsInventoryScript" Visible="true">
<MamlContent>
<maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
<maml:title>Summary</maml:title>
<maml:para>This alert is generated when the SCOM.WindowsInventory.ps1 script experiences runtime problems or finds agent configuration issues.</maml:para>
</maml:section>
<maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
<maml:title>Resolution</maml:title>
<maml:para>The alert description shows the section of code that had an issue.</maml:para>
</maml:section>
</MamlContent>
</KnowledgeArticle>
</KnowledgeArticles>
</LanguagePack>
</LanguagePacks>
<Resources>
<Assembly ID="Resource.SCOM.Task.Ping" Accessibility="Public" FileName="SCOM.Task.Ping" HasNullStream="true" QualifiedName="SCOM.Task.Ping" />
<Assembly ID="Resource.SCOM.Task.RDP" Accessibility="Public" FileName="SCOM.Task.RDP" HasNullStream="true" QualifiedName="SCOM.Task.RDP" />
</Resources>
</ManagementPack>
